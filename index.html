<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="HandsomeDong">










<meta property="og:type" content="website">
<meta property="og:title" content="HandsomeDong七里翔">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HandsomeDong七里翔">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HandsomeDong七里翔">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: false,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>HandsomeDong七里翔</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HandsomeDong七里翔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/03/聊聊我最近的分库分表骚操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/03/聊聊我最近的分库分表骚操作/" itemprop="url">聊聊我最近的分库分表骚操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-10-03T20:11:07+08:00">
                2021-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>国庆前这段时间一直都在搞分库分表相关的东西，中间遇到了比较多的问题，不过最后还是都艰难地解决掉了。这段时间感觉挺累但又挺有意思的，需要思考的点很多，所以决定写篇博客<del>水</del>总结一下。毕竟因为最近在刷算法题，没更新过什么博客了，趁国庆时间比较多，赶紧卷一卷。<br><img src="https://img-blog.csdnimg.cn/c2225430e10b4562bc25d966864039e9.jpg#pic_center" alt="水一篇博客"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>先说一下背景吧。我们项目之前是完全没做分库分表的，现在有几张核心的表，数据量已经非常大了，数据量最大的一张表已经有接近250亿的数据了……我刚开始看到这张表的数据量是比较惊讶的，而且还跟DBA大佬了解了一下，现在线上这张表的操作耗时非常短，暂时没有性能问题。一般来说，千万级的数据量应该已经比较影响性能了，现在这个表已经差不多250亿数据了，还不出问题？<br><img src="https://img-blog.csdnimg.cn/a4a50e6a14d64d889e6f9c42327635e3.png#pic_center" alt="？"></p>
<p>我分析了一下这张表的结构，然后看了一下相关的SQL，我认为这张表暂时还没有性能问题有以下两点：</p>
<ol>
<li>数据结构简单。这是一张文件表，里面的字段不多，只有主键id、文件名、key、hash、url、大小等字段，占用的空间也不大</li>
<li>SQL不复杂。我分析了一下与这张表有关系的所有SQL，发现这张表几乎没有update操作（有是有，但是只有一个SQL，而且那个方法还被废弃了，我们现在的业务基本上不会对这张表的数据进行修改），只有insert和select操作，而且select操作大部分都是通过主键id作为条件查询，少量是通过hash字段来进行查询，所以需要维护的索引也不多，只有主键索引和这个hash字段的普通索引。所以这张表的相关SQL是比较简单的。</li>
</ol>
<p>虽然现在没有性能问题，但是嘛……现在这张表每个月的增长速度是亿级别的，再不做分库分表，迟早要出问题。所以我决定先对它出手了！另外几张表的数据量也很大，但是与之相关的操作太复杂了，所以我觉得我得先找个简单的表实践实践，积累一点经验后再对其它几张表下手。<br><img src="https://img-blog.csdnimg.cn/60b58989885642a2a029268729dfce20.gif#pic_center" alt="在这里插入图片描述"></p>
<h1 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案"></a>分库分表方案</h1><p>分库分表主要有垂直切分和水平水平，这次针对的问题是单表容量达到瓶颈的问题，因此采用<strong>水平切分</strong>。</p>
<p><strong>以下把这张表叫做 t_file 表吧。</strong></p>
<h2 id="切分策略"><a href="#切分策略" class="headerlink" title="切分策略"></a>切分策略</h2><p>水平切分策略主要有hash切分和范围切分，优缺点如下表。<br>| 切分策略 | 实现 | 优点 | 缺点 |<br>|–|–|–|–|<br>| hash切分 | hash取模mod | 数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈 | 1.后期分片集群扩容需要迁移旧的数据。<br> 2.容易面临跨分片查询的复杂问题<br>| 范围切分 | 按照时间区间或ID区间来切分 | 1.单表大小可控<br>2.便于水平扩展<br>3.对范围查找友好 | 热点可能容易成为性能瓶颈 |</p>
<p><strong>最终经过考虑，决定采用范围切分策略</strong>，主要原因是 t_file 的主键原来是整型的自增主键，不适合用hash切分。目前数据量非常大，并且还涉及到另外几张表，有些表存储了一个列表，列表里存的就是整型ID，那些表也非常大，改的话影响范围太大，所以不可能把整型修改成其它类型。</p>
<h2 id="不分库，只分表"><a href="#不分库，只分表" class="headerlink" title="不分库，只分表"></a>不分库，只分表</h2><p>这张表我们有没有必要分库呢？我和我的mentor讨论了一下，觉得是暂时只做分表即可。只要原因有以下几个：</p>
<ol>
<li>我们有主从，做了读写分离（也不算完全读写分离，个别对延时方面要求高的SQL读的是主库），并且跟DBA大佬讨论过，数据库压力并没有那么大。而且我们如果在主从上又做分库，那每个实例启动后都需要连接并且管理大量的数据源，需要消耗大量资源，不是很值得</li>
<li>这张表，是存在一个独立的库中的，那个库只有这一张表！由于这张表数据里较大，之前我们就把这张表分出来放到一个独立的库中了，它跟其它表并不是在同一个数据库。所以它压力更小了</li>
<li>由于是水平切分，我们后期要是再想做分库的话，不用再次迁移数据，或者说迁移数据的复杂度很低，并且路由规则也不需要改太多。以后我们想做分库再做就是了，现在不用一步到位</li>
</ol>
<p><strong>所以最终决定不分库，只分表。</strong></p>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>目前比较主流的分库分表中间件有mycat、sharding-jdbc、tidb，最终决定使用sharding-jdbc，原因有下：</p>
<ol>
<li>现在只打算分表，而不分库，Mycat和tidb并没有太大优势</li>
<li>mycat是proxy层解决方案，需要部署、维护，并且本身是单点的，高可用性差，如果想要集群还需要再引入别的中间件</li>
<li>tidb资源利用率低、维护成本也很高</li>
</ol>
<p><strong>综合业务及中间件优缺点考虑，sharding-jdbc较为合适。</strong><br><img src="https://img-blog.csdnimg.cn/2ccda90f6bbb4040845c37649d4e1bf4.jpg#pic_center" alt="就用sharding-jdbc"></p>
<h1 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h1><p>写的过程碰到了几个问题，搞了点骚操作。<br><img src="https://img-blog.csdnimg.cn/c8f044b7d9664254b89d6f775cac2b1c.gif#pic_center" alt="满脑子骚操作"></p>
<h2 id="分布式ID实现"><a href="#分布式ID实现" class="headerlink" title="分布式ID实现"></a>分布式ID实现</h2><h3 id="不重复的ID该怎么实现？"><a href="#不重复的ID该怎么实现？" class="headerlink" title="不重复的ID该怎么实现？"></a>不重复的ID该怎么实现？</h3><p><strong>分库分表后，需要保证数据插入后ID的唯一性</strong>，实现不重复的ID一般有以下几种方案：</p>
<ol>
<li>使用雪花算法生成ID。雪花算法会生成64 bit的ID，转成字符串后长度是19位（有个表需要存储文件表数据ID），长度比较长。如果我们使用了雪花算法，那另一个表每一行的数据都会膨胀很多，这就不是很划算了……</li>
<li>实现发号器。可通过redis的incrby实现全局单调ID生成器，从而保证唯一性。但是这个方案会使插入数据操作强依赖于中间件，必须考虑到持久化、高可用等问题，实现一个靠谱的发号器需要考虑到的地方太多，不容易落地。</li>
<li>使用UUID。我们要用整型ID，UUID没法满足。</li>
<li><strong>使用数据库的自增ID</strong>。该表的数据比较特殊，只会新增，不会删除，并且极少有修改操作，因此可以考虑继续使用数据库的自增ID。而要保证每个表的ID都不重复，那就要先确定好每个表的ID范围没有交集，再在建表时设置好表的起始自增序列号，业务方需要确保在插入数据时判断该表的最大ID必须小于下一个表的起始自增序列号。例如我们打算每个表存储100行数据，那么 t_file_0 表的ID范围为 0 ~ 99（当然，我们没有ID为0的数据，最小的是1），t_file_1 表的ID范围为 100 ~ 199 ，t_file_2 表的ID范围为 200 ~ 299……</li>
</ol>
<p><strong>方案四实现全局唯一ID比较简单，类型符合我们要求，性能也没有损耗，因此决定采用方案四。但是问题接踵而至。</strong></p>
<p>使用方案四，就会有三个问题：</p>
<ol>
<li>建表前需要确认好每个表的ID范围，建表时设置好起始自增序列号</li>
<li><strong>在插入ID时维护好当前要插入的数据对应的表下标</strong>，根据上面的例子，当 t_file 里的数据最大ID为99时，后面的数据不能再插入到该表中，而是要插入到 t_file_1 中，这意味着我们需要维护一个当前数据对应的表下标，即“我需要知道现在的数据需要插入到哪个表”</li>
<li>使用自己的策略就意味着不能使用sharding-jdbc的ID生成策略了</li>
</ol>
<p>第一个问题只需运维或者后端开发建表前注意一下即可，而第二个问题则需要在代码中解决，而第三个问题，只需要我们把表下标传进mapper，交给mybatis帮我们拼装到SQL里面即可。</p>
<p><strong>所以现在主要是要解决第二个问题。</strong><br><img src="https://img-blog.csdnimg.cn/6b855c47ef304083ac7fc508239f8912.png#pic_center" alt="愁"></p>
<h2 id="表下标维护"><a href="#表下标维护" class="headerlink" title="表下标维护"></a>表下标维护</h2><p>那么要怎么维护这个表下标呢？我当时是思考了一个下午，一步步优化，得到一个自认为不错的方案（太佩服我自己了吧），而且实现也不复杂。<strong>这个方案就是每个表预留一部分ID，然后每个实例各自维护一个表下标，不存储在redis中。</strong></p>
<p>下面来看看整个优化的过程。<br><img src="https://img-blog.csdnimg.cn/518f43b1fd8f4cc485b3112588ca4d20.png#pic_center" alt="我真是个天才"></p>
<h3 id="插入前查询maxId"><a href="#插入前查询maxId" class="headerlink" title="插入前查询maxId"></a>插入前查询maxId</h3><p>最直接的写法就是每次批量插入数据前，先查询表的最大ID，再加上当前的数据量，预测插入数据后的ID是否还在范围内，若超过了该范围，就把下标+1，更新到redis中，然后把数据插入到下一个表中。<br><img src="https://img-blog.csdnimg.cn/c780dae7556c4e0bb8396bef588323d3.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiD6YeM57-U,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="插入前查询maxId"></p>
<p>单线程下这种做法当然没有问题，但是多线程问题就大了，何况这个业务并发量还那么高。</p>
<p>假设 t_file_0 的ID范围是0 ~ 9999，现在该表最大的ID是9995，此时2个线程同时插入数据，这2个线程都插入4行数据……2个线程获取到的tableIndex都是0，并且查了一下maxId加上自己的数据量，最后得到9999，在范围内，然后同时插入数据……那么 t_file_0 这个表就会出现ID超过了9999的情况，而 t_file_1 的ID范围是 10000~19999，ID重复了！</p>
<p>所以很明显，<strong>这个方案不靠谱。</strong></p>
<h3 id="插入后查询maxId"><a href="#插入后查询maxId" class="headerlink" title="插入后查询maxId"></a>插入后查询maxId</h3><p>既然插入后的ID可能会超出范围，那我们能不能在插入后再检查一下maxId呢？如果maxId超出范围，就回滚事务，再更新tableIndex，把数据插入到下一张表中。<br><img src="https://img-blog.csdnimg.cn/aab14646598542eeaad907c1e0439300.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiD6YeM57-U,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="插入后查询maxId"><br>这种做法比较靠谱，插入后再检查ID，再决定是否提交事务，就不会出现最大ID超过该表范围这种情况了。<strong>但是却要手动控制事务。</strong></p>
<h3 id="预留ID"><a href="#预留ID" class="headerlink" title="预留ID"></a>预留ID</h3><p>那能不能再优化一下呢？我不想控制事务回滚然后再提交一次……</p>
<p>所以我想到了预留最后一部分ID的做法，<strong>我可以让每张表都预留一部分ID，这部分ID可以插入一部分数据，但是插入之后，以后的数据就插入到下一张表。只要我们预留的ID范围足够大，那在高并发场景下就不会出现ID超范围的情况。</strong></p>
<p>比如 t_file_0 的预留ID范围是 9000~9999，当插入一批数据后得到的最大ID是9100，达到了预留ID范围，那就更新表下标，以后的数据插入到 t_file_1 中。即使多个线程同时插入一大批数据，只要我们预留的范围足够大，就不会出现最大ID超过这张表范围的情况。这样就不用手动控制事务了。<br>而我们需要查询的时候，ID为 0 ~ 9999（包括预留的那部分ID，9000 ~ 9999） 还是路由到 t_file_0 进行查询，所以插入和查询都是不会有问题的。</p>
<p><img src="https://img-blog.csdnimg.cn/21801bc2d7434ba58a98d81d9d9cc30f.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiD6YeM57-U,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="预留ID"><br>但是这样又依赖与中间件了，这样的话，redis一出问题，那可能就会影响到当前业务的新增操作了。</p>
<h3 id="预留ID-不依赖redis"><a href="#预留ID-不依赖redis" class="headerlink" title="预留ID + 不依赖redis"></a>预留ID + 不依赖redis</h3><p>上面的方案，都是在redis维护了一个表下标。这样的话，redis一出问题，那可能就会影响到当前业务的新增操作了，但是<strong>实际上表下标是不需要在redis中再维护一份的，我只需要在每个实例中维护自己的一个下标就行了！</strong></p>
<p>这样的话，会有这个问题：当其中一个实例插入数据后，发现自己的下标要+1了，其它的实例无法感知到。</p>
<p><strong>但是这个问题并不会使ID重复，因为只要我预留的ID足够大，保证其它实例再插入数据的时候，不会超过当前表的最大ID，就不会出现问题！并且我们插入数据是分批插入的，每批最多100个数据</strong>。比如要插入1000个数据，我会分成10批数据，每批数据插入完成后都会检查一下maxId并更新表。所以理论上，只要满足这个条件，就绝对不会有重复ID的问题发生（<strong>当然我是测过的，你完全可以相信七里翔</strong>）： </p>
<blockquote>
<p><strong>预留ID数 &gt; 实例数 <em> 每个实例的最大线程数 </em> 100</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/ce063a80027f49f7abd70ba5fb6592b7.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiD6YeM57-U,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="预留ID + 不依赖redis"></p>
<h2 id="多数据源、sharding-jdbc、主从怎么结合到一块？"><a href="#多数据源、sharding-jdbc、主从怎么结合到一块？" class="headerlink" title="多数据源、sharding-jdbc、主从怎么结合到一块？"></a>多数据源、sharding-jdbc、主从怎么结合到一块？</h2><p>使用sharding-jdbc的shardingsphere，我又遇到了以下两个问题：</p>
<ol>
<li>在项目中使用了我们自己写的一个多数据源的组件，与shardingsphere数据源冲突</li>
<li>我们的分表+主从数据库架构不适合用shardingsphere</li>
</ol>
<p>针对这两个问题，我决定优化多数据源组件，整合shardingsphere。</p>
<h3 id="怎么解决多数据源和shardingsphere数据源冲突的问题？"><a href="#怎么解决多数据源和shardingsphere数据源冲突的问题？" class="headerlink" title="怎么解决多数据源和shardingsphere数据源冲突的问题？"></a>怎么解决多数据源和shardingsphere数据源冲突的问题？</h3><p>我们的项目中要到了一个自己开发多数据源组件，把这个多数据源组件的DataSource注到mybatis中，可以通过注解动态切换数据源。但是现在用shardingsphere，会跟这个组件起冲突。</p>
<p>看了一天源码后，我最后决定把shardingsphere集成到我们的多数据源组件中。我先在shardingsphere基础上写个自动配置类，封装多个shardingsphere的datasource，然后交给多数据源去管理。也就是，数据源组件只需要负责帮我切换数据源到shardingsphere，剩下的分片、路由相关的操作还是交给shardingsphere本身去完成。完美解决二者冲突的问题！</p>
<h3 id="怎么解决分表-主从数据库不适合用shardingsphere的问题？"><a href="#怎么解决分表-主从数据库不适合用shardingsphere的问题？" class="headerlink" title="怎么解决分表+主从数据库不适合用shardingsphere的问题？"></a>怎么解决分表+主从数据库不适合用shardingsphere的问题？</h3><p>我们的数据库是主从，现在使用shardingsphere来管理 t_file 表的路由，想要切换到从库数据源，只有两个办法：</p>
<ol>
<li>使用Hint分片策略，强制切换数据源。这种办法不靠谱，每次使用前都需要路由到指定的具体库和表，将产生大量重复的业务代码</li>
<li>配置shardingsphere的读写分离。这种方法也不靠谱，我们不一定所有的读都走从库，再加上我们有个别sql查询是不走shardingsphere的，这意味着这部分查询语句没法使用shardingsphere的读写分离。</li>
</ol>
<p>这两种方法都没法满足我们的业务需求，最终我决定再优化多数据源组件，使用多数据源管理多个shardingsphere DataSource。<br>通过配置多个shardingsphere数据源，把主数据库和从数据库配置到不同的shardingsphere数据源中，再注入到多数据源组件中，通过注解切换到不同的shardingsphere数据源，即可实现主从库数据源的切换，同时还能使用shardingsphere的功能，主从数据源共用同一套表路由算法，并且方便以后其它表使用shardingsphere来进行表路由。<br><img src="https://img-blog.csdnimg.cn/b8ee278f0d934eca934132b32bb878be.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiD6YeM57-U,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="dynamic-datasource和shardingsphere结合"></p>
<h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><h2 id="部分SQL性能问题"><a href="#部分SQL性能问题" class="headerlink" title="部分SQL性能问题"></a>部分SQL性能问题</h2><p>虽然这个表涉及的SQL不多，并且不复杂，但是还是有个别SQL可能会出现问题。<br>比如刚才说到的，通过hash查询某一行数据。有2个SQL，分别是这样：需要通过hash匹配查询第一行数据；需要通过hash匹配查询最后一行数据。<br>这2个SQL肯定不能走shardingsphere来查询的了，因为我的分片键只有id，这种查询条件不是分片键的SQL，会在所有的表中执行一次，最后在汇合处理，这样的效率肯定是非常低的。<br>还好这2个SQL也不复杂，我最后自己优化了一下。不通过shardingsphere去做路由，而是我自己传入表下标。比如需要通过hash匹配查询第一行数据，我传下标0进去执行SQL，数据为空，下标+1再查下一个表。直到查询到一行数据或者下标超出了当前插入数据的表下标（tableIndex）为止。</p>
<h1 id="上线前准备"><a href="#上线前准备" class="headerlink" title="上线前准备"></a>上线前准备</h1><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>上线前需要运维协助建表并迁移数据，分表后每张表数据量为20亿，预留10万个ID。<br><img src="https://img-blog.csdnimg.cn/b59c7d9f72bf4cf0ad705e1899dee678.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiD6YeM57-U,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="数据迁移"></p>
<h2 id="服务切换"><a href="#服务切换" class="headerlink" title="服务切换"></a>服务切换</h2><p>服务更新与服务回滚是比较重要的环节，这个得要提前规划好。考虑好怎么样才能将服务切换时的影响降到最低。我刚开始的方案是，预留一部分主键ID，具体方案如下。</p>
<h3 id="预留一部分主键ID"><a href="#预留一部分主键ID" class="headerlink" title="预留一部分主键ID"></a>预留一部分主键ID</h3><p>采取预留一部分主键ID的方案让新旧服务能同时运行而不会产生主键冲突。</p>
<p>假如现在线上有250亿数据，按照每张表20亿数据分表，则可以分为13张表，下标为 0 ~ 12 ，t_file_12 的主键范围是 240亿~260亿-1，全量同步后开启增量同步，把后续新增的数据也同步过去。</p>
<p>假设增量的数据有1亿，那么增量同步差不多完成后，t_file_12 中的最大主键大概是251亿，还有9亿的ID可用。</p>
<p>这个时候新服务上线，新服务新增的数据插入到 t_file_13 中，而 t_file_13 的起始自增序列号为260亿，所以新旧服务一起运行时，一定时间内并不会出现主键冲突的情况。因此新服务上线后可以开启双向同步，观察新服务上线后的情况，确认完全没有问题后再关闭旧服务、双向同步。</p>
<p>整个过程的步骤为：</p>
<ol>
<li>在新库中新建课件文件表</li>
<li>全量同步</li>
<li>增量同步追加数据</li>
<li>开启双向同步</li>
<li>上线新服务</li>
<li>新服务无异常，关掉旧服务和双向同步</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b668d4869b894181b2215c4c9fc14842.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiD6YeM57-U,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="预留一部分主键ID"><br>当我说完这个方案后，我自信满满，此时我的表情是这样的👇。<br><img src="https://img-blog.csdnimg.cn/5eacb660f08944a9a652f7b82bda826a.gif#pic_center" alt="自信满满"><br>但是，DBA大佬的表情先是这样的👇。<br><img src="https://img-blog.csdnimg.cn/696b08f5796f485e8e79a6927c252216.png#pic_center" alt="?"><br>然后，变成了这样👇。<br><img src="https://img-blog.csdnimg.cn/6617a978bef2436e9c37020d4ce3f9f0.png#pic_center" alt="!"><br>我内心慌了起来。</p>
<p>DBA大佬说：小伙子，这个上线方案不行。假如一个表原本的当前的自增序列号是10，而你插入了一行数据，这行数据里面包含了ID（即不是使用自增ID）的话，是会更新自增序列号的，比如你插入了一个ID为15的数据，那这个时候表的自增序列号就会变成16，而不是原来的10了。</p>
<p>我……<br><img src="https://img-blog.csdnimg.cn/1abd5ed41885470cba4a540d08e59405.jpg#pic_center" alt="是我太菜"></p>
<h3 id="最后的方案"><a href="#最后的方案" class="headerlink" title="最后的方案"></a>最后的方案</h3><p>还是DBA大佬经验丰富，和他讨论过后，我豁然开朗。最终的上线步骤是这样的。</p>
<ol>
<li>运维开启全量同步，把旧库数据同步到新库中</li>
<li>上线新服务（版本1），双写，先旧后新，数据全部从旧库读取。新库中的ID需和旧库中保持一致</li>
<li>下线旧服务，新旧服务同时运行的过程中旧服务产生的增量数据由运维处理，补到新库中</li>
<li>上线新服务（版本2），双写，先旧后新，数据全部从新库中读取</li>
<li>上线新服务（版本3），双写，先新后旧，数据全部从新库中读取。旧库的ID需和新库保持一致</li>
<li>新服务在线上运行一段时间没出现问题后，再更新代码上线新服务（版本4），去除双写机制，只需在新库中读写数据，旧库废弃</li>
</ol>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>新建表的时候的存储过程如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> create_tables()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">str</span> = <span class="string">"(</span></span><br><span class="line"><span class="string">  `c_id` bigint unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">  `c_create_time` datetime NOT NULL,</span></span><br><span class="line"><span class="string">  `c_modify_time` datetime NOT NULL,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`c_id`),</span></span><br><span class="line"><span class="string">  KEY `idx_c_hash` (`c_hash`) USING BTREE,</span></span><br><span class="line"><span class="string">  KEY `idx_name` (`c_name`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB AUTO_INCREMENT="</span>;</span><br><span class="line"><span class="keyword">set</span> @j = <span class="number">0</span>;</span><br><span class="line">while @j &lt; 100 do</span><br><span class="line"><span class="keyword">set</span> @auto_increment = @j * <span class="number">2000000000</span>;</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">table</span> = <span class="keyword">concat</span>(<span class="string">'t_file_'</span>,@j);</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">end</span> = <span class="string">" DEFAULT CHARSET=utf8"</span>;</span><br><span class="line"><span class="keyword">set</span> @sql_t = <span class="keyword">concat</span>(<span class="string">"CREATE TABLE "</span>,@<span class="keyword">table</span>, @<span class="keyword">str</span>, @auto_increment, @<span class="keyword">end</span>);</span><br><span class="line"><span class="keyword">prepare</span> sql_t <span class="keyword">from</span> @sql_t;</span><br><span class="line"><span class="keyword">execute</span> sql_t;</span><br><span class="line"><span class="keyword">set</span> @j = @j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> create_tables();</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> create_tables;</span><br></pre></td></tr></table></figure>
<h2 id="多数据源组件"><a href="#多数据源组件" class="headerlink" title="多数据源组件"></a>多数据源组件</h2><p><strong>我感觉这个多数据源组件有点意思。所以我在国庆这两天自己也写了个多数据源组件，并且集成了shardingsphere。感兴趣的可以点我头像，里面有我<a href="https://github.com/HandsomeDong" target="_blank" rel="noopener">github主页链接</a>，里面一个名为 dynamic-datasource-spring-boot-starter 的仓库就是这个项目了。</strong></p>
<h1 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h1><h2 id="假如要分库"><a href="#假如要分库" class="headerlink" title="假如要分库"></a>假如要分库</h2><p>现在是只做分表的情况，我可以把表下标传进去给mybatis拼到SQL里面。但是如果做了分库后要怎么办呢？</p>
<p>这个我也考虑到了，假如要做分库的话，那数据库的路由就需要交给sharingsphere去完成了，我能想到的是：用shardingsphere的hint强制路由策略，然后自己实现自定义注解，并且实现相应的路由策略，按理说是可以满足分库的需求的。</p>
<p>不过嘛，没实践过怎么会知道有没有其它问题呢？等有空了我再实现试试。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/02/SpringBoot-Dubbo简单demo实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/02/SpringBoot-Dubbo简单demo实践/" itemprop="url">SpringBoot+Dubbo简单demo实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-02T13:56:41+08:00">
                2021-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringBoot-Dubbo-简单-demo-实践"><a href="#SpringBoot-Dubbo-简单-demo-实践" class="headerlink" title="SpringBoot + Dubbo 简单 demo 实践"></a>SpringBoot + Dubbo 简单 demo 实践</h1><p>休息了一个月终于又要上班了，下家公司的项目用的是Dubbo+Zookeeper，由于之前只用过Spring Cloud，所以提前了解一下Dubbo的使用，搭了个简单的 demo 感受 Dubbo 和 Spring Cloud 的区别。<br>大概流程如下：</p>
<ol>
<li>Zookeeper搭建</li>
<li>Dubbo可视化管理界面搭建</li>
<li>接口层定义</li>
<li>服务层实现</li>
<li>消费层调用</li>
</ol>
<h2 id="Dubbo基本工作原理"><a href="#Dubbo基本工作原理" class="headerlink" title="Dubbo基本工作原理"></a>Dubbo基本工作原理</h2><p>Dubbo 是一款 RPC 服务框架，它最大的优势在于提供了面向接口代理的服务编程模型，对开发者屏蔽了底层的远程通信细节。同时 Dubbo 也是一款服务治理框架，它为分布式部署的微服务提供了服务发现、流量调度等服务治理解决方案。</p>
<p>下图是 Dubbo 的基本工作原理图(在官网找的)，服务提供者与服务消费者之间通过注册中心协调地址，通过约定的协议实现数据交换。<br><img src="https://img-blog.csdnimg.cn/20210702113353557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="Dubbo 基本工作原理图"><br>接下来就搭建一个 demo ，感受一下 Dubbo 的使用和 Spring Cloud 有什么区别。</p>
<h2 id="Zookeeper搭建"><a href="#Zookeeper搭建" class="headerlink" title="Zookeeper搭建"></a>Zookeeper搭建</h2><h3 id="Zookeeper下载"><a href="#Zookeeper下载" class="headerlink" title="Zookeeper下载"></a>Zookeeper下载</h3><p>Dubbo 使用 Zookeeper 作为注册中心，提供服务注册和发现，跟Spring Cloud的 eureka 或 nacos 类似。</p>
<p>所以第一步当然是去<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">官网</a>下载 Zookeeper 啦，我下载的版本是3.6.3。</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>下载解压后，进入 conf 文件夹可以看到有个 zoo_sample.cfg 文件，这个是配置文件示例，现在复制并更名为 zoo.cfg ，根据自己的需要对配置进行更改，我改了一下数据路径。<br>Zookeeper 的端口号默认是2181，可以根据自己的需要对 clientPort 的值进行更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataDir=E:/zookeeper/data</span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>进入bin文件夹可以看到里面有很多脚本，zkServer.cmd 和 zkServer.sh 就是启动脚本，我的电脑系统是 windows ，所以直接双击 zkServer.cmd 即可启动。</p>
<p><img src="https://img-blog.csdnimg.cn/20210702113029700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="启动Zookeeper"></p>
<h2 id="Dubbo-可视化管理界面搭建"><a href="#Dubbo-可视化管理界面搭建" class="headerlink" title="Dubbo 可视化管理界面搭建"></a>Dubbo 可视化管理界面搭建</h2><p>Zookeeper 启动完成之后，我们需要一个可视化界面方便对服务进行观察和管理。</p>
<h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><p>Dubbo-admin的Github地址是 <a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin</a> ，直接 git clone 下来。项目里有 readme.md 介绍启动流程，参考 readme.md 启动项目。</p>
<h3 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h3><p>打开 dubbo-admin\dubbo-admin-server\src\main\resources\application.properties 可以修改配置，指定 Zookeeper 地址，我的 Zookeeper 是默认配置，所以不用修改。</p>
<h3 id="编译、打包项目"><a href="#编译、打包项目" class="headerlink" title="编译、打包项目"></a>编译、打包项目</h3><p>进入到项目里编译并打包项目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>
<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>可以直接在项目根目录运行 mvn –projects dubbo-admin-server spring-boot:run 启动项目，也可以进入 dubbo-admin-distribution\target 运行里面的jar包。</p>
<p><img src="https://img-blog.csdnimg.cn/20210702120409974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="启动 dubbo-admin"></p>
<p><strong> 启动失败 </strong><br>我刚开始启动失败了，这个 dubbo-admin 的启动端口是 8080，但是我发现 8080 端口已经被占用了，最后发现是 Zookeeper 占用的，原来是 Zookeeper 内嵌了一个管理控制台，通过 jetty 启动，这个 jetty 的端口就是 8080，于是我去改了以下 Zookeeper 的 zoo.cfg ，新增了一行配置把 Zookeeper 的管理控制台端口改为 8081。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.serverPort=8081</span><br></pre></td></tr></table></figure>
<h3 id="进入管理界面"><a href="#进入管理界面" class="headerlink" title="进入管理界面"></a>进入管理界面</h3><p>启动成功后就可以访问 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a> 了，默认的账号密码都是root。<br><img src="https://img-blog.csdnimg.cn/20210702120820273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="登录"><br><img src="https://img-blog.csdnimg.cn/20210702120905244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="Dubbo Admin"></p>
<h2 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h2><p>接下来就要创建工程了，先创建个 maven 多模块工程，里面需要包含三个模块，一个是 api 模块，一个是服务提供者模块，一个是服务消费者模块。</p>
<h3 id="api模块"><a href="#api模块" class="headerlink" title="api模块"></a>api模块</h3><p>假设我这个服务是一个用户查询的服务，那我就需要先创建一个 dto 和一个接口。<br><img src="https://img-blog.csdnimg.cn/20210702122334353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="api 模块"></p>
<h4 id="创建-UserInfo-类"><a href="#创建-UserInfo-类" class="headerlink" title="创建 UserInfo 类"></a>创建 UserInfo 类</h4><p>创建一个用户信息类，需要注意的是，dto 要实现 Serializable 接口进行序列化。当然，也可以使用其它的序列化方式，hessian2、json等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class UserInfo implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2908612893636115165L;</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    private Long userId;</span><br><span class="line"></span><br><span class="line">    public static long getSerialVersionUID() &#123;</span><br><span class="line">        return serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getUserId() &#123;</span><br><span class="line">        return userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserId(Long userId) &#123;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义用户服务接口"><a href="#定义用户服务接口" class="headerlink" title="定义用户服务接口"></a>定义用户服务接口</h4><p>简单定义一个接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public List&lt;UserInfo&gt; getUserInfoList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务提供者模块"><a href="#服务提供者模块" class="headerlink" title="服务提供者模块"></a>服务提供者模块</h3><p>现在创建一个服务提供者模块。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>这个模块需要 Dubbo 和 Zookeeper 相关依赖，再加上这个模块是要实现 UserService 接口，所以也需要刚才创建的 api 模块依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;dubbo.version&gt;2.7.5&lt;/dubbo.version&gt;</span><br><span class="line">    &lt;curator.version&gt;2.12.0&lt;/curator.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Zookeeper dependencies --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.handsomedong&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>配置文件主要需要以下配置：<br><img src="https://img-blog.csdnimg.cn/20210702124035217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="配置文件"></p>
<p>根据上图的配置，修改 application.yml，我的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line"></span><br><span class="line">debug: true</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: user-service-provider</span><br><span class="line">  registry:</span><br><span class="line">    address: 127.0.0.1:2181</span><br><span class="line">    protocol: zookeeper</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 19000</span><br><span class="line">  monitor:</span><br><span class="line">    protocol: registry</span><br></pre></td></tr></table></figure></p>
<h4 id="用户服务类具体实现"><a href="#用户服务类具体实现" class="headerlink" title="用户服务类具体实现"></a>用户服务类具体实现</h4><p>实现用户服务接口，注意这里的 @Service 注解，不是 Spring 的注解，而是 Dubbo 的注解！包的全路径是 org.apache.dubbo.config.annotation.Service。<br>并且需要注意的是，它必须要实现 UserService 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Component</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;UserInfo&gt; getUserInfoList() &#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            UserInfo userInfo = new UserInfo();</span><br><span class="line">            userInfo.setUserId(Integer.valueOf(i).longValue());</span><br><span class="line">            userInfo.setUserName(&quot;七里翔&quot; + i);</span><br><span class="line">            userInfoList.add(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return userInfoList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringBoot-启动类"><a href="#SpringBoot-启动类" class="headerlink" title="SpringBoot 启动类"></a>SpringBoot 启动类</h4><p>最后在启动类要加上 @EnableDubbo 注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableDubbo</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class UserProviderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查看-Dubbo-Admin"><a href="#查看-Dubbo-Admin" class="headerlink" title="查看 Dubbo Admin"></a>查看 Dubbo Admin</h4><p>现在再去 Dubbo Admin 上面就可以看到这个服务注册成功了！点击详情也可以看到服务的具体信息。<br><img src="https://img-blog.csdnimg.cn/20210702124820859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="Dubbo Admin"><br><img src="https://img-blog.csdnimg.cn/20210702124935459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="服务详情"></p>
<h3 id="服务消费者模块"><a href="#服务消费者模块" class="headerlink" title="服务消费者模块"></a>服务消费者模块</h3><p>最后就是创建服务消费者模块了，在该模块下进行服务调用。</p>
<h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><p>依赖基本和服务提供者相同，这个就不多BB了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;dubbo.version&gt;2.7.5&lt;/dubbo.version&gt;</span><br><span class="line">    &lt;curator.version&gt;2.12.0&lt;/curator.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Zookeeper dependencies --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.handsomedong&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10000</span><br><span class="line">debug: true</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: user-service-consumer</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:2181</span><br><span class="line">  monitor:</span><br><span class="line">    protocol: registr</span><br></pre></td></tr></table></figure>
<h4 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h4><p>我这里直接创建个 Controller 来测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;test&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @Reference	//dubbo</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;test&quot;)</span><br><span class="line">    public List&lt;UserInfo&gt; test() &#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = userService.getUserInfoList();</span><br><span class="line">        return userInfoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringBoot-启动类-1"><a href="#SpringBoot-启动类-1" class="headerlink" title="SpringBoot 启动类"></a>SpringBoot 启动类</h4><p>这个启动类同样要加上 @EnableDubbo 注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableDubbo</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class UserConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动服务消费者后，断点调试、用 postman 测试一下。<br><img src="https://img-blog.csdnimg.cn/2021070213174837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="断点调试"></p>
<p><img src="https://img-blog.csdnimg.cn/20210702131812576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="postman"><br>可以看到已经大功告成了！！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Dubbo-和-Spring-Cloud-区别"><a href="#Dubbo-和-Spring-Cloud-区别" class="headerlink" title="Dubbo 和 Spring Cloud 区别"></a>Dubbo 和 Spring Cloud 区别</h3><ol>
<li>Dubbo 耦合较高，有一定约束。这是我使用中感受到的最大的区别，Dubbo 需要我们定义个抽象接口，然后提供方实现这个接口，消费方再通过这个接口进行调用。提供方和消费方都依赖于这个接口的模块，所以整个项目是有一定的耦合的。而Spring Cloud 我们使用 Feign 就比较自由，比较轻量化，通过 REST 调用，更灵活。这不能单纯地说是优点或者是缺点吧，毕竟接口定义过轻也很容易多版本的情况下导致接口文档与实际所展现功能不一致导致服务集成时的问题，或许对版本控制比较严格有时候反而会更加稳定。</li>
<li>Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输的；而 Spring Cloud 是基于 Http 协议+ REST 接口调用远程过程的通信。在传输协议和序列化方式上，Dubbo 的性能要比 Spring Cloud 更高。因为 Dubbo 是长连接并且用二进制传输，占用带宽更少。而 Spring Cloud 使用的是短连接并且使用 JSON 序列化，消耗更大。</li>
<li>Dubbo 只是一个 RPC 框架，而 Spring Cloud 是一整套微服务的解决方案，因此它们的领域是不一样的。</li>
<li>社区方面，Spring Cloud 要比 Dubbo 活跃很多很多很多很多……Dubbo 好久没更新了，而 Spring Cloud 目前还一直在更新，很活跃！</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210702134836992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="Dubbo 流泪"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/31/记一次简单的服务启动GC优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/31/记一次简单的服务启动GC优化/" itemprop="url">记一次简单的服务启动GC优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-31T23:31:36+08:00">
                2021-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天上线一个项目的时候在日志里发现项目启动的时候频繁GC，花了点时间分析了一下并且调整了一下JVM参数。</p>
<h1 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h1><p>项目启动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xmx1024m -XX:MaxDirectMemorySize=<span class="number">512</span>M -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.txt -jar xxxxxxxx.jar</span><br></pre></td></tr></table></figure>
<p>gc.txt<br><img src="https://img-blog.csdnimg.cn/20201203194421400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="GC记录"><br>好家伙，一启动就来9次 Young GC ，2次 Full GC。</p>
<p>现在先用jinfo看看配置参数<br><img src="https://img-blog.csdnimg.cn/20201203195944270.png" alt="查看JVM参数"><br>注意几个重要参数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">62914560</span>		<span class="comment">//堆初始值</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">1073741824</span>	<span class="comment">//堆最大值</span></span><br><span class="line">-MaxDirectMemorySize=<span class="number">536870912</span>	<span class="comment">//虚拟机外最大内存</span></span><br></pre></td></tr></table></figure></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>先来分析这两次Full GC以及它们前面的Young GC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.536</span>: [GC (Metadata GC Threshold) [PSYoungGen: <span class="number">19883</span>K-&gt;<span class="number">3584</span>K(<span class="number">128512</span>K)] <span class="number">27143</span>K-&gt;<span class="number">12014</span>K(<span class="number">169472</span>K), <span class="number">0.0158155</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"><span class="number">2.552</span>: [Full GC (Metadata GC Threshold) [PSYoungGen: <span class="number">3584</span>K-&gt;<span class="number">0</span>K(<span class="number">128512</span>K)] [ParOldGen: <span class="number">8430</span>K-&gt;<span class="number">8782</span>K(<span class="number">32256</span>K)] <span class="number">12014</span>K-&gt;<span class="number">8782</span>K(<span class="number">160768</span>K), [Metaspace: <span class="number">20409</span>K-&gt;<span class="number">20409</span>K(<span class="number">1069056</span>K)], <span class="number">0.0844666</span> secs] [Times: user=<span class="number">0.16</span> sys=<span class="number">0.00</span>, real=<span class="number">0.09</span> secs]</span><br><span class="line"><span class="number">4.965</span>: [GC (Metadata GC Threshold) [PSYoungGen: <span class="number">109848</span>K-&gt;<span class="number">8697</span>K(<span class="number">247296</span>K)] <span class="number">119422</span>K-&gt;<span class="number">19608</span>K(<span class="number">279552</span>K), <span class="number">0.0278398</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.01</span>, real=<span class="number">0.03</span> secs]</span><br><span class="line"><span class="number">4.993</span>: [Full GC (Metadata GC Threshold) [PSYoungGen: <span class="number">8697</span>K-&gt;<span class="number">0</span>K(<span class="number">247296</span>K)] [ParOldGen: <span class="number">10910</span>K-&gt;<span class="number">14513</span>K(<span class="number">47104</span>K)] <span class="number">19608</span>K-&gt;<span class="number">14513</span>K(<span class="number">294400</span>K), [Metaspace: <span class="number">33512</span>K-&gt;<span class="number">33512</span>K(<span class="number">1081344</span>K)], <span class="number">0.1136122</span> secs] [Times: user=<span class="number">0.20</span> sys=<span class="number">0.00</span>, real=<span class="number">0.11</span> secs]</span><br></pre></td></tr></table></figure>
<p>可以看到两次Full GC都是由于Metadata GC Threshold造成的。我这里用的是JDK8，参数里没有明确指定metaspace的初始值和上限，这个时候初始值应该是默认的 21M 。问题不大，那我就把它的初始值和上限调大一点吧，调到64M。</p>
<p>措施：<br><strong>追加元空间初始值</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -XX:MetaspaceSize=<span class="number">64</span>m -XX:MaxMetaspaceSize=<span class="number">64</span>m -Xmx1024m -XX:MaxDirectMemorySize=<span class="number">512</span>M  -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.txt -jar xxxxxxxx.jar</span><br></pre></td></tr></table></figure>
<p>这个时候再查看gc.txt<br><img src="https://img-blog.csdnimg.cn/2020120320223724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70" alt="gc.txt"><br>可以看到已经没有Full GC了，不过还是有8次Young GC。</p>
<h2 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h2><p>其实从我的启动参数里面就可以看到，<strong>堆的容量我只指定了最大值(-Xmx1024m)</strong>，并没有指定初始值。所以可以在配置参数里面看到 -XX:InitialHeapSize=62082048，即<strong>堆的初始容量只有60m左右。</strong></p>
<p>而JVM默认的新生代和老年代空间占比为 <strong>1 : 3</strong>，所以新生代在一开始的时候只有15m的内存空间，因此JVM一开始在15m的时候就发生了Young GC。</p>
<p>所以现在要追加新生代和堆的初始值，新生代、老年代的空间占比我就不调了，使用默认的 1 : 3 即可，而堆的初始值调成1024m，这样新生代的初始值就是256m了。</p>
<p>措施：<br><strong>追加堆的初始值</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms1024m -XX:MetaspaceSize=<span class="number">64</span>m -XX:MaxMetaspaceSize=<span class="number">64</span>m -Xmx1024m -XX:MaxDirectMemorySize=<span class="number">512</span>M  -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.txt -jar xxxxxxxx.jar</span><br></pre></td></tr></table></figure>
<p>现在再来看看gc.txt<br><img src="https://img-blog.csdnimg.cn/20201203203514210.png" alt="gc.txt"><br>可以看到只有两次Young GC了，这两次Young GC是在新生代对象准备超过256m的时候发生的……</p>
<p><strong>好家伙，既然如此，那我也不讲武德了，我现在就把堆初始值和最大值都调成100G。</strong><br><img src="https://img-blog.csdnimg.cn/20201203204915316.png#pic_center" alt="过分"><br>好吧，公司穷，只能买得起4G的服务器。<br><img src="https://img-blog.csdnimg.cn/20201203205647704.png#pic_center" alt="哭了"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这只是一次很简单的JVM启动参数优化，平时启动应用的时候还是得多注意注意堆的初始值和最大值配置，元空间这部分也不能忽略了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/14/JDK7HashMap多线程扩容导致的死循环问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/14/JDK7HashMap多线程扩容导致的死循环问题/" itemprop="url">JDK7HashMap多线程扩容导致的死循环问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-14T21:46:19+08:00">
                2020-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">JDK8以前的HashMap，多线程扩容的时候可能会出现死循环，这个问题在JDK8得到了修复。本翔看了大半天JDK7HashMap扩容源码找这个问题，所以写篇博客记录记录。</font></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>先来看看JDK7的HashMap扩容相关源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//扩容</span><br><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">       int newCapacity = newTable.length;</span><br><span class="line">       //遍历旧桶数组</span><br><span class="line">       for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">           while(null != e) &#123;</span><br><span class="line">           	//先记录下一次循环要插入的节点</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               if (rehash) &#123;</span><br><span class="line">                   e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">               //计算新下标</span><br><span class="line">               int i = indexFor(e.hash, newCapacity);</span><br><span class="line">               //下面这两步很明显了，头插法。即先拿到桶原本指向的节点，把要插入的节点的next指向它，然后再把桶指向这个要插入的节点</span><br><span class="line">               e.next = newTable[i];</span><br><span class="line">               newTable[i] = e;</span><br><span class="line">               //next记录了旧数组旧链表里的下一个节点，现在把e指向它，准备下次循环把它插到新桶</span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 transfer 方法用的是头插法，我们重点注意以下几个步骤：</p>
<blockquote>
<p>1.Entry&lt;K,V&gt; next = e.next;     next指向旧链表中的下一个节点<br>2.e.next = newTable[i];      把新链表的头结点摘下来放到将要插入的节点的尾部<br>3.newTable[i] = e;        插入节点，即把桶指向e<br>4.e = next;        把e指向next，准备继续插入下一个节点</p>
</blockquote>
<h1 id="多线程扩容"><a href="#多线程扩容" class="headerlink" title="多线程扩容"></a>多线程扩容</h1><p>单线程的情况下扩容，是没什么问题的，我们直接来一步步分析多线程扩容的时候会出现什么问题。</p>
<blockquote>
<p>假如扩容前的数组和链表是这样的，数组里有2个桶，桶1里有三个节点，它们的键分别为3、7、5。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201114210933754.png#pic_center" alt="扩容前"></p>
<blockquote>
<p>1 现在有两个线程同时扩容这个数组。假如线程一先拿到了cpu资源，执行完了 <strong>Entry&lt;K,V&gt; next = e.next;</strong> 这一步后，e指向3，next指向7。<br>这时CPU资源交给了线程二，好家伙，线程二啪啦啪啦啪啦一下子就把整个链表都迁移了过去，直接扩容完成。<br>这个时候旧数组、链表和两个线程的状态是这样的。<br><img src="https://img-blog.csdnimg.cn/20201114211611593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="线程二扩容完成"></p>
</blockquote>
<blockquote>
<p>2 现在轮到线程一继续执行了。线程一一顿操作猛如虎，执行完第一次循环后，把3插了进去，然后把next赋给了e，还记得在线程二执行的时候，线程一的next是7吗？现在e指向的节点就是7，准备下一次循环插入7。第一次循环过后变成了这样：<br><img src="https://img-blog.csdnimg.cn/20201114211819832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="第一次循环结束"></p>
</blockquote>
<blockquote>
<p>3 下次循环一开始，<strong>Entry&lt;K,V&gt; next = e.next</strong> 直接把next指向3。问题不大，没毛病。现在继续执行下去，把7的next指向3，然后再把桶指向7，即用头插法插入了7。执行完第二次循环后如下图，现在问题已经差不多出来了，执行完此次循环后，e指向了3，但是3已经被插入了，继续执行下去会怎么样呢？<br><img src="https://img-blog.csdnimg.cn/20201114212639171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="第二次循环结束"></p>
</blockquote>
<blockquote>
<p>4 这次循环执行情况是这样的<br>Entry&lt;K,V&gt; next = e.next;    现在e是3，而3的next是null，所以next指向了null<br>e.next = newTable[i];        这一步把3的next指向了7，因为桶现在是指向7的<br>newTable[i] = e;            把桶指向3<br>e = next;        由于next是null了，所以e指向了null，跳出了while进行后面的for循环<br>现在问题出来了，3的next指向了7，而7的next原本就指向3，情况如下图：<br><img src="https://img-blog.csdnimg.cn/20201114214042697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="第三次循环结束出大问题"></p>
</blockquote>
<p>显而易见，环形链表出现，这个时候如果我们再去做一些查询，查到这个桶3上面来的话，遍历的时候就出现了死循环，直接出不去了，出大问题……<br>还好JDK8修复了这个死循环问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/14/JDK8-HashMap源码理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/14/JDK8-HashMap源码理解/" itemprop="url">JDK8 HashMap源码理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-14T18:09:51+08:00">
                2020-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">最近本翔再次认真阅读了HashMap的源码，总结一下自己的一些理解，希望对大家能有点帮助。</font></p>
<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><p>HashMap的数据结构是数组+链表，数组里面是一个个Node，在JDK8中加入了红黑树。HashMap根据存入的对象的hash跟数组长度取模得出下标，如果发生了哈希冲突，则新插入的键值对会放到上一个节点的后面，形成链表。当链表长度超过8且数组长度也不小于64时会转为红黑树，同理，链表长度小于6时会再次变回链表。数组里的每个存储空间，我们称为桶(bucket)。<br><img src="https://img-blog.csdnimg.cn/20201114005720673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="HashMap内部"></p>
<h2 id="1-1-Node"><a href="#1-1-Node" class="headerlink" title="1.1 Node"></a>1.1 Node</h2><p>Node封装了key和value，我们使用put方法塞进去key和value其实都存到了Node里面，看看Node里面的成员变量有哪些。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;K,V&gt; <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;K,V&gt; &#123;</span></span><br><span class="line">    final <span class="keyword">int</span> hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ………………略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到里面有四个成员</p>
<blockquote>
<p>hash值：即键的散列值<br>key：就是我们put进去的那个键了<br>value：就是我们put进去的那个值了<br>next：下一个节点</p>
</blockquote>
<h2 id="1-2-重要参数"><a href="#1-2-重要参数" class="headerlink" title="1.2 重要参数"></a>1.2 重要参数</h2><p>HashMap里面定义了一些比较重要的参数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> final <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;    <span class="comment">//初始容量</span></span><br><span class="line"><span class="keyword">static</span> final <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> final <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;    <span class="comment">//负载因子，当map里面的node数量大于 threshold = loadFactor * capacity时，就会扩容</span></span><br><span class="line"><span class="keyword">static</span> final <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;    <span class="comment">//桶的树化阈值，转为红黑树的哈希冲突数量阈值</span></span><br><span class="line"><span class="keyword">static</span> final <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;    <span class="comment">//桶的链表还原阈值，转为链表的哈希冲突数量阈值</span></span><br><span class="line"><span class="keyword">static</span> final <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;    <span class="comment">//最小树形化容量阈值，当哈希表中的容量即数组长度不小于该值时，树形化链表</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>1.初始容量和加载因子我们在实例化HashMap的时候是可以定义的。当 元素数量 &gt; 容量*加载因子 时，数组就会扩容。<br>2.当桶里面的 链表长度 &gt; TREEIFY_THRESHOLD 且 桶数组长度 &gt; MIN_TREEIFY_CAPACITY 时，链表就会转换为红黑树。</p>
</blockquote>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><h2 id="2-1-扰动函数"><a href="#2-1-扰动函数" class="headerlink" title="2.1 扰动函数"></a>2.1 扰动函数</h2><p>没仔细看源码前，我一直以为计算桶下标的时候值直接用键的hashCode跟数组容量相与得出的下标，现在仔细一看才发现事情没那么简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> final <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == null) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到扰动函数里面把hashCode右移了16位再与原hashCode进行了异或操作，即用自己的高16位和低16位进行了异或。这样能增加随机性，让数据元素更散列，减少碰撞。</p>
<h2 id="2-2-插入"><a href="#2-2-插入" class="headerlink" title="2.2 插入"></a>2.2 插入</h2><p>简单来说，插入键值对的时候，先通过键的哈希值计算出下标，然后再把数据存放到数组中。不多BB，直接放源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">final V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, boolean onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               boolean evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果数组未初始化，则先初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == null || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果桶里没数据，直接新建一个Node，并把桶指向这个Node</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    <span class="comment">//桶里有数据再做处理</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//键值和键散列值都和桶里的第一个Node键值和键hashCode一样，直接把e指向这个Node，准备后面直接替换值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果是TreeNode对象，则调用红黑树插入值的方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//即不是树节点，且第一个Node也不是要找的Node，那就准备遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//遍历链表且统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">            	<span class="comment">//遍历完链表都没有这个key，那就在链表后面插入新节点吧</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    <span class="comment">//链表长度大于阈值的话就转为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到key，结束遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//e不为空则表示链表里包含有要插入的键值对，直接替换值就好了</span></span><br><span class="line">        <span class="keyword">if</span> (e != null) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//元素数量超过threshold时就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤如下：</p>
<blockquote>
<p>1.检查桶数组是否为空，为空则resize()初始化<br>2.计算下标，用桶数组长度 - 1跟键的哈希值相与，即(length - 1) &amp; hash 计算下标，看桶是否为空，为空就直接把Node存进桶中<br>3.如果桶里第一个Node的key和当前的key一样，直接将桶指向现在的Node<br>4.如果Node是树节点，就调用红黑树的插入方法<br>5.如果以上两种情况都不是，则需要遍历该链表，找到对应的key替换值或者没有key就往链表尾部插入新Node<br>6.所有元素处理完成后，判断size是否超过阈值 threshold，是则resize()扩容</p>
</blockquote>
<h2 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h2><p>查找就比较简单，就计算出数组下标，到桶里面看看是红黑树还是链表还是null，再拿数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//桶里有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != null) &#123;</span><br><span class="line">        <span class="comment">//如果桶里第一个就是要找的，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != null) &#123;</span><br><span class="line">        	<span class="comment">//树节点，调红黑树的查询方法</span></span><br><span class="line">            <span class="keyword">if</span> (first instanceof TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-树形化"><a href="#2-4-树形化" class="headerlink" title="2.4 树形化"></a>2.4 树形化</h2><p>由于从链表中查找数据的时间复杂度是O(n)，所以如果插入的键值对，发生哈希碰撞太多而导致链表过长的时候，那性能是非常差的。所以在JDK8中，链表长度大于8且桶容量不小于64时，链表会树形化，即转为红黑树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">final <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//可以看到，如果桶数组容量小于64时，就算链表长度大于8，也只会扩容而不会把链表转为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	<span class="comment">//注意，这里只是把普通节点转成了树节点，现在还不是红黑树</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">            <span class="keyword">if</span> (tl == null)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != null)</span><br><span class="line">        	<span class="comment">//这里才是转红黑树，红黑树内容略多，就不在这篇博客详细总结了</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-扩容"><a href="#2-5-扩容" class="headerlink" title="2.5 扩容"></a>2.5 扩容</h2><p>扩容可以有效避免有太多的哈希碰撞而导致的桶内数据过多的情况。桶数组容量 * 负载因子大于元素数量时，HashMap就会扩容，把数组容量扩大一倍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == null) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//容量不为空，即已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">//容量达到 2^30 ，不会再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容量增加一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//初始化新的桶数组</span></span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != null) &#123;</span><br><span class="line">    	<span class="comment">//遍历旧的桶数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//桶里面有数据，准备迁移</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                <span class="comment">//如果桶里只有一个节点的话，直接把新桶指向这个节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果桶里指向的是树节点，则调用红黑树的拆分操作</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//桶里的链表不止一个节点，则需要遍历链表一个个迁移</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//这里用哈希跟旧数组长度相与，计算出该节点是放在高位桶还是低位桶</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != null);</span><br><span class="line">                    <span class="comment">//把新桶指向链表头节点，数据迁移完成</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结扩容操作步骤，其实主要就以下几个步骤：</p>
<blockquote>
<p>1.没初始化就初始化，容量达到MAXIMUM_CAPACITY即2^30就不扩容了<br>2.新建桶数组，容量为旧的桶数组的2倍<br>3.遍历旧数组的所有桶，桶里链表只有一个数据就直接迁移，是树节点就调用红黑树的拆分方法，链表不止一个数据就遍历链表<br>4.由于新桶数组容量是原来的两倍，所以原本在同一个桶中的数据迁移到新数组中时，是有可能放在不同的两个桶中的。一个是低位桶，下标值和原来的一样，一个是高位桶，下标值和原来的差值为旧桶数组的容量，通过 hash&amp;oldCap 是否等于0可以判断这个节点是在高位桶还是低位桶</p>
</blockquote>
<p>为什么 (hash&amp;oldCap==0) 可以判断一个节点是在高位桶还是低位桶呢？</p>
<blockquote>
<p>一个节点的数组下标，是通过它的键的hash跟数组容量取模计算得来的，所以同一个桶上的数据，要么它们的hash相等，要么它们的hash相差 2^n 个数组容量。<br>比如两个哈希值分别为13和5的键，插进数组长度为8的桶数组里，1101&amp;0111 和 0101&amp;0111 计算得到的下标都是0101，即5。当扩容后，数组长度为16，而这时再计算下标时， 就变成了 1101&amp;1111和0101&amp;1111，最终的结果分别为13和5，它们相差8。哈希值为5的节点扩容后仍然在下标值为5的桶上，而哈希值为13的节点已经迁移到了下标值为8的桶上了。<br>其实不难发现，通过位于运算计算下标时，扩容前的0111和扩容后的1111只相差第四位的那个1，由于哈希值为13的第四位原本是1，而哈希值为5的第四位原本是0，当位于运算的值有0111变成1111时，第四位也参与了运算，才导致了扩容后的它们得出的下标值会不同。所以我们可以直接用1000跟hash进行相与，看看它的第四位是1还是0就可以知道它是在高位桶还是低位桶了。</p>
</blockquote>
<h1 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h1><h2 id="3-1-桶数组长度为什么总是2的n次方"><a href="#3-1-桶数组长度为什么总是2的n次方" class="headerlink" title="3.1 桶数组长度为什么总是2的n次方"></a>3.1 桶数组长度为什么总是2的n次方</h2><blockquote>
<p>计算效率更高，计算更方便。<br>取模(%)操作中如果除数是2的幂次，则等价于与其除数减一的与(&amp;)操作（前提是length是2的n次方）。所以可以从源码中看到，计算数组下标是通过 hash &amp; (length - 1) 来计算的。而且这样使扩容后计算新位置会更方便，从扩容源码中可以看到判断一个节点扩容后的数组下标是在高位桶还是低位桶时，直接用hash跟旧桶数组容量相与即可判断，并在如果是高位桶，直接用下标加上旧数组长度即可拿到高位桶的下标。</p>
</blockquote>
<h2 id="3-2-HashMap的参数loadFactor，它的作用是什么？"><a href="#3-2-HashMap的参数loadFactor，它的作用是什么？" class="headerlink" title="3.2 HashMap的参数loadFactor，它的作用是什么？"></a>3.2 HashMap的参数loadFactor，它的作用是什么？</h2><blockquote>
<p>其实从源码中可以看得很清楚了，它其实是表示HashMap里面数组所能承受的拥挤程度，影响hash操作到同一个数组位置的概率。默认的loadFactor是0.75，当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，在HashMap的构造器中可以定制loadFactor。</p>
</blockquote>
<h2 id="3-3-HashMap从JDK7到JDK8的变化。"><a href="#3-3-HashMap从JDK7到JDK8的变化。" class="headerlink" title="3.3 HashMap从JDK7到JDK8的变化。"></a>3.3 HashMap从JDK7到JDK8的变化。</h2><blockquote>
<p>1.树形化<br>首先肯定就是新增了红黑树啦，JDK7及之前桶中只有链表一种数据结构，JDK8中桶内元素大于8且数组容量不小于64时便会把桶内链表转为红黑树。<br>2.hash计算方式不同<br>JDK7的扰动函数，前前后后进行了四次扰动。而JDK8简化了这一操作，只是对高低位做了异或。<br>3.扩容操作中，下标的计算方法不一样。<br>可以从JDK8源码中看到resize()里面，判断节点是高位桶还是低位桶，是高位桶的话，直接用旧的下标加上旧的数组容量即可。但是JDK7中不是这样的，JDK7的扩容操作需要对节点重新计算下标。<br>4.发生哈希碰撞时，插入链表中的方法不一样。<br>JDK8里的HashMap插入元素时，用的是尾插法，但是JDK7里用的是头插法。在进行扩容操作迁移元素时也是如此，这就导致JDK7的HashMap在多线程进行扩容操作时，有可能会出现死锁问题！这里就不详细描述JDK7HashMap的死锁问题了，后面会专门出篇博客翔谈该问题。（不要问我为什么是“翔谈”不是“详谈”，我叫七里翔）</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/15/树莓派使用samba在局域网共享文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/15/树莓派使用samba在局域网共享文件/" itemprop="url">树莓派使用samba在局域网共享文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-15T00:18:43+08:00">
                2019-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/树莓派/" itemprop="url" rel="index">
                    <span itemprop="name">树莓派</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>新买的树莓派4终于到了！！！我的树莓派3B+光荣退休！到手第一步当然是用树莓派通过SMB共享我硬盘里的文件啦，随传随看。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114191323554.jpg" alt="你懂的"></p>
<h3 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h3><p>samba是一个能让Linux系统应用Microsoft网络通讯协议的软件，而SMB是Server Message Block的缩写，即为服务器消息块 ，SMB主要是作为Microsoft的网络通讯协议，后来samba将SMB通信协议应用到了Linux系统上，就形成了现在的samba软件。后来微软又把 SMB 改名为 CIFS（Common Internet File System），即公共 Internet 文件系统，并且加入了许多新的功能，这样一来，使得samba具有了更强大的功能。</p>
<p>所以首先得安装samba。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install samba samba-common-bin</span><br></pre></td></tr></table></figure></p>
<h3 id="新建用户并与要共享的文件夹绑定"><a href="#新建用户并与要共享的文件夹绑定" class="headerlink" title="新建用户并与要共享的文件夹绑定"></a>新建用户并与要共享的文件夹绑定</h3><p>接下来先新建一个用户用于其它设备通过samba访问共享文件夹时登录访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd share	//新建用户</span><br><span class="line">passwd share    //设置用户密码</span><br><span class="line">mkdir /home/share    //新建一个文件夹</span><br><span class="line">chown -R share /home/share    //绑定</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201114191429468.jpg" alt="新建用户"></p>
<h3 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h3><p>用户和文件夹都建好了，现在就要根据情况修改配置了。配置文件路径是 /etc/samba/smb.conf ，打开这个文件，在文件最后添加共享账户和共享文件夹的一些信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HandsomeDong]	#网络中显示的文件名称</span><br><span class="line">    path = /home/share	#文件路径</span><br><span class="line">    valid users = share	#允许浏览的用户</span><br><span class="line">    browseable = yes	#允许浏览</span><br><span class="line">    public = yes		#允许共享访问</span><br><span class="line">    writable = yes		#允许写入</span><br></pre></td></tr></table></figure>
<h3 id="设置共享密码以及重启"><a href="#设置共享密码以及重启" class="headerlink" title="设置共享密码以及重启"></a>设置共享密码以及重启</h3><p>访问共享文件时，用的是samba设置的共享密码，而不是linux用户密码，现在要设置的就是共享密码，设置好后直接重启samba服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a share</span><br><span class="line">service smbd restart</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201114191520419.jpg" alt="设置密码、重启samba服务"></p>
<h3 id="访问共享文件夹"><a href="#访问共享文件夹" class="headerlink" title="访问共享文件夹"></a>访问共享文件夹</h3><h4 id="电脑访问"><a href="#电脑访问" class="headerlink" title="电脑访问"></a>电脑访问</h4><p>用windows系统访问共享文件夹，只需在资源管理器输入 \\IP 就可以直接看到共享文件夹了，输入用户名和共享密码就可以访问了。现在把我前几天买的1T硬盘挂载到这个文件夹下，我就可以肆意地往里面存片子了！！！</p>
<p><img src="https://img-blog.csdnimg.cn/20201114191605648.jpg" alt="文件夹"></p>
<p><img src="https://img-blog.csdnimg.cn/20201114191655170.jpg" alt="输入用户名、密码"></p>
<p><img src="https://img-blog.csdnimg.cn/20201114191717536.jpg" alt="片子"></p>
<h4 id="安卓手机访问"><a href="#安卓手机访问" class="headerlink" title="安卓手机访问"></a>安卓手机访问</h4><p>安卓手机有不少APP都能使用SMB协议，我用的比较多的是 Solid Explorer 和 Kodi。Solid Explorer用来管理文件，视频、文本、音频、图片什么的浏览、管理起来都比较方便，Kodi浏览视频和图片非常好，非常强大！</p>
<h3 id="ipad、iphone访问"><a href="#ipad、iphone访问" class="headerlink" title="ipad、iphone访问"></a>ipad、iphone访问</h3><p>App Store上有很多软件都可以，收费的体验更好！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/使用cryptsetup加密硬盘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/使用cryptsetup加密硬盘/" itemprop="url">使用cryptsetup加密硬盘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T21:54:35+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/树莓派/" itemprop="url" rel="index">
                    <span itemprop="name">树莓派</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在京东关注移动硬盘好久了，等了很久终于等到希捷移动硬盘几个月以来的最低价……299！咬咬牙终于下单，今天早上到手。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114185225708.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="1T希捷移动硬盘"></p>
<p>这个移动硬盘主要用来给我的树莓派外接，然后用SMB共享，这样在内网条件下，我的手机、电脑、平板等就可以随时访问硬盘里的内容了，不过在此之前，我还得对硬盘进行加密，免得谁偷偷把我硬盘拿走了后随意浏览里面一些不可描述的东西。<br>cryptsetup是linux下的一个分区加密工具，它通过调用内核中的”dm-crypt”来实现磁盘加密的功能，这个加密工具应该还挺常用的，我的树莓派就是用的这个加密工具。不过在此之前，我们得先初始化这个硬盘</p>
<p><img src="https://img-blog.csdnimg.cn/20201114185314876.jpg#pic_center" alt="不可描述"></p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h4 id="找到设备"><a href="#找到设备" class="headerlink" title="找到设备"></a>找到设备</h4><p>第一步先对硬盘进行分区。把移动硬盘插到树莓派上，用 <strong>fdisk -l</strong> 看看是哪个硬盘。</p>
<p><img src="https://img-blog.csdnimg.cn/2020111418540061.jpg#pic_center" alt="fdisk -l"></p>
<p>很明显这个 /dev/sdb1 就是我插进去的移动硬盘。</p>
<h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h4><p>现在输入命令 <strong>fdisk /dev/sdb1</strong> 来操作这个硬盘。然后可以输入 m 来查看操作提示。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114185454794.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="操作提示"></p>
<p>可以看到 n 是添加新分区，那就输入 <strong>n</strong> 吧。<br><img src="https://img-blog.csdnimg.cn/20201114185659938.jpg#pic_center" alt="添加新分区"></p>
<p>这个时候询问我们是要创建主分区还是扩展分区，主分区最多只能创建4个，如果创建了扩展分区那么扩展分区需要占用一个主分区，直接enter则默认是主分区，后面还有询问分区序号、分区大小什么的，我一路直接enter了，即默认。<br><img src="https://img-blog.csdnimg.cn/20201114185740894.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="创建主分区"></p>
<p>创建好后可以输入 <strong>p</strong> 来查看逻辑分区。<br><img src="https://img-blog.csdnimg.cn/20201114185821330.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="查看逻辑分区"></p>
<p>可以看到我此时是只有一个分区的，大小是931.5G，现在可还没分区成功，还需要输入 <strong>w</strong> 保存。</p>
<h3 id="加密格式化"><a href="#加密格式化" class="headerlink" title="加密格式化"></a>加密格式化</h3><p>OK，现在硬盘基本的初始化完成了，现在要开始对它进行加密了。我这里用的是分区加密工具是cryptsetup，没有的话需要先安装。安装方法很简单，这里就不详细介绍了。<br>现在输入 <strong>cryptsetup luksFormat /dev/sdb1</strong> ，然后输入YES确认（注意要大写），再输入你要给硬盘设置的密码。<br><img src="https://img-blog.csdnimg.cn/20201114185918841.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="加密格式化"></p>
<h3 id="打开并挂载硬盘"><a href="#打开并挂载硬盘" class="headerlink" title="打开并挂载硬盘"></a>打开并挂载硬盘</h3><h4 id="打开加密的硬盘"><a href="#打开加密的硬盘" class="headerlink" title="打开加密的硬盘"></a>打开加密的硬盘</h4><p>输入 <strong>cryptsetup luksOpen /dev/sdb1 test</strong> ，并且输入密码后，硬盘 /dev/sdb1 会被映射到 /dev/mapper/test 下。<br><img src="https://img-blog.csdnimg.cn/20201114185954951.jpg#pic_center" alt="打开硬盘"></p>
<h4 id="格式化映射的设备"><a href="#格式化映射的设备" class="headerlink" title="格式化映射的设备"></a>格式化映射的设备</h4><p>现在还需要再格式化一下映射的设备，执行 <strong>mkfs.ext4 /dev/mapper/test</strong>，这步操作只需在第一次打开设备时需要，以后再打开、挂载硬盘可以就无需这步操作了。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114190037490.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="格式化映射设备"></p>
<h4 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h4><p>这个时候想要挂载硬盘，直接把映射的目录挂载就行， <strong>mount /dev/mapper/test /home/HandsomeDong</strong> 。<br><img src="https://img-blog.csdnimg.cn/20201114190121843.jpg#pic_center" alt="挂载硬盘"></p>
<h3 id="卸载硬盘"><a href="#卸载硬盘" class="headerlink" title="卸载硬盘"></a>卸载硬盘</h3><p>想要卸载、拔出硬盘，需要先卸载挂载点，再关闭映射的设备，切忌热插拔，容易损坏硬盘。<br>卸载挂载点 <strong>umount /home/HandsomeDong</strong><br>关闭映射设备 <strong>cryptsetup luksClose test</strong><br><img src="https://img-blog.csdnimg.cn/20201114190154672.jpg#pic_center" alt="卸载硬盘"></p>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="数据无法读取"><a href="#数据无法读取" class="headerlink" title="数据无法读取"></a>数据无法读取</h4><p>硬盘意外断电再重新挂载时可能会造成数据无法读取，这时可以使用fsck修复指定分区。<br><strong>fsck /dev/mapper/HandsomeDong</strong><br><img src="https://img-blog.csdnimg.cn/20201114190246843.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMTE1NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="修复分区"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/Spring-Autowire注入Map和List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/Spring-Autowire注入Map和List/" itemprop="url">Spring @Autowire注入Map和List</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-17T22:55:23+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天要实现一个需求，我们要同时使用阿里云和白山云的对象存储，在上传或者删除一些文件时，两个对象存储都要做同样的操作。由于是不同的平台，配置、SDK什么的都不一样，因此我写了一个接口让它们去实现，然后我再在service调用bean的方法去操作文件。本来还想用@Autowire和@Qualifier分别注入这两个bean再塞到一个list去调用它们，然后突然发现@Autowired能直接注入Map或List，把实现该接口的所有的bean塞到一个集合中，实在是太棒太灵活了！<br><img src="https://img-blog.csdnimg.cn/20201114184730276.jpg" alt="太棒了"></p>
<p>那么就不多BB了，直接上代码。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Cat implements Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, this is &quot; + this.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Dog implements Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, this is &quot; + this.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3><p>可以注入Map或者List，指定泛型是那个接口类型即可。下面是测试的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private List&lt;Animal&gt; animalList;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Map&lt;String, Animal&gt; animalMap;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        for (Animal animal : animalList) &#123;</span><br><span class="line">            animal.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = animalMap.keySet();</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            animalMap.get(key).sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>断点看了一下变量，可以看到在Map里面，key就是bean的名字。<br><img src="https://img-blog.csdnimg.cn/2020111418481998.jpg" alt="测试断点"></p>
<p>下面是运行结果。<br><img src="https://img-blog.csdnimg.cn/2020111418481978.jpg" alt="运行结果"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/08/Spring-Security的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/Spring-Security的问题/" itemprop="url">Spring Security CSRF防御</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T22:02:57+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作中遇到的问题/" itemprop="url" rel="index">
                    <span itemprop="name">工作中遇到的问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在公司开发一个用Spring Boot框架的项目，用POST上传文件的时候死活上传不了，一直都是返回403，忙活了一个上午才发现是因为Spring Sercurity开启了CSRF防御，所以在POST请求中必须还要包含增加一个字段及数据才能请求成功，不然的话都会被Spring Sercurity给拦截掉并且认为是非法请求，比如我要提交表单数据，必须要增加一个隐藏的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;$&#123;_csrf.parameterName&#125;&quot; value=&quot;$&#123;_csrf.token&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>详情可以在官方文档中看到，<a href="https://docs.spring.io/autorepo/docs/spring-security/3.2.0.CI-SNAPSHOT/reference/html/csrf.html" target="_blank" rel="noopener">https://docs.spring.io/autorepo/docs/spring-security/3.2.0.CI-SNAPSHOT/reference/html/csrf.html</a></p>
<h3 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3><p>看了一下官方文档才了解到这CSRF到底是什么，就像文档所说的，假如银行网站向用户提供转账功能，转账请求的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /transfer HTTP/1.1</span><br><span class="line">Host: bank.example.com</span><br><span class="line">Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">amount=100.00&amp;routingNumber=1234&amp;account=9876</span><br></pre></td></tr></table></figure>
<p>但是假如你登录到了银行网站，然后在还没注销的情况下又访问了一个恶意网站，这时你看到恶意网站上有个【领取奖品】按钮，你美滋滋地点击了这个按钮，却不知道这个按钮会提交这样的表单信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;https://bank.example.com/transfer&quot; method=&quot;post&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot;</span><br><span class="line">      name=&quot;amount&quot;</span><br><span class="line">      value=&quot;100.00&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot;</span><br><span class="line">      name=&quot;routingNumber&quot;</span><br><span class="line">      value=&quot;evilsRoutingNumber&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot;</span><br><span class="line">      name=&quot;account&quot;</span><br><span class="line">      value=&quot;evilsAccountNumber&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot;</span><br><span class="line">      value=&quot;Win Money!&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>最后你会收到一条信息，您向银行卡号XXX转账100元……当场流下悔恨的泪水，大喊三声“为什么”？！<br>因为恶意网站虽然没办法获取你的cookie信息，但是它向银行后端请求的时候，浏览器还是会将cookie信息一起发送的，银行当然不知道这个请求是恶意网站向它发送的，它只知道cookie是你的！</p>
<p><strong>像这种伪装成当前已登录认证用户去请求正在访问的网站后端的攻击方式，就被称为CSRF。</strong></p>
<p>所以解决办法就是增加一些表单信息，而这些信息是恶意网站所无法获取的！例如图片验证码什么的。但是除了登录注册的时候使用验证码外，其它时候也使用验证码的话，用户岂不是会觉得很烦，所以Spring Sercurity通过在WEB应用中增加前端过滤器，验证请求是否包含CSRF的token信息，不包含的自然就是非法请求咯，因为攻击网站是无法获取到token信息的，只要是跨域提交的信息，都是无法通过这个过滤器的校验的。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>下面是CsrfFilter中的doFilterInternal源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response, FilterChain filterChain)</span><br><span class="line">					throws ServletException, IOException &#123;</span><br><span class="line">		request.setAttribute(HttpServletResponse.class.getName(), response);</span><br><span class="line">		// 先从tokenRepository中加载token</span><br><span class="line">		CsrfToken csrfToken = this.tokenRepository.loadToken(request);</span><br><span class="line">		final boolean missingToken = csrfToken == null;</span><br><span class="line">		  // 如果为空，则tokenRepository生成新的token，并保存到tokenRepository中</span><br><span class="line">		if (missingToken) &#123;</span><br><span class="line">			csrfToken = this.tokenRepository.generateToken(request);</span><br><span class="line">			this.tokenRepository.saveToken(csrfToken, request, response);</span><br><span class="line">		&#125;</span><br><span class="line">        // 将token写入request的attribute中，方便页面上使用</span><br><span class="line">		request.setAttribute(CsrfToken.class.getName(), csrfToken);</span><br><span class="line">		request.setAttribute(csrfToken.getParameterName(), csrfToken);</span><br><span class="line">		//这个macher就是我们在Spring配置文件中自定义的过滤器，也就是GET，HEAD, TRACE, OPTIONS和我们的rest都不处理</span><br><span class="line"> </span><br><span class="line">        // 这个macher就是我们在Spring配置文件中自定义的过滤器，</span><br><span class="line">		//如果不需要csrf验证的请求，则直接下传请求（requireCsrfProtectionMatcher是默认的对象，对符合^(GET|HEAD|TRACE|OPTIONS)$的请求和我们自定义的请求不验证）</span><br><span class="line">		if (!this.requireCsrfProtectionMatcher.matches(request)) &#123;</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">        // 从用户请求中获取token信息</span><br><span class="line">		String actualToken = request.getHeader(csrfToken.getHeaderName());</span><br><span class="line">		if (actualToken == null) &#123;</span><br><span class="line">			actualToken = request.getParameter(csrfToken.getParameterName());</span><br><span class="line">		&#125;</span><br><span class="line">        // 验证，如果相同，则下传请求，如果不同，则抛出异常</span><br><span class="line">		if (!csrfToken.getToken().equals(actualToken)) &#123;</span><br><span class="line">			if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">				this.logger.debug(&quot;Invalid CSRF token found for &quot;</span><br><span class="line">						+ UrlUtils.buildFullRequestUrl(request));</span><br><span class="line">			&#125;</span><br><span class="line">			if (missingToken) &#123;</span><br><span class="line">				this.accessDeniedHandler.handle(request, response,</span><br><span class="line">						new MissingCsrfTokenException(actualToken));</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				this.accessDeniedHandler.handle(request, response,</span><br><span class="line">						new InvalidCsrfTokenException(csrfToken, actualToken));</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		filterChain.doFilter(request, response);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>唉，有空还是得多到Spring官网看看文档了解了解框架啊，不然一个简单的问题就得搞半天！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/JVM基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HandsomeDong七里翔">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HandsomeDong七里翔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/JVM基础/" itemprop="url">JVM基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T16:31:24+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM基础知识"><a href="#JVM基础知识" class="headerlink" title="JVM基础知识"></a>JVM基础知识</h1><blockquote>
<p>最近看《深入理解Java虚拟机》学习到了一些JVM基础知识，主要了解了JVM运行时数据区域、GC以及类加载机制，现在来总结一下。</p>
</blockquote>
<h2 id="JVM的跨平台性"><a href="#JVM的跨平台性" class="headerlink" title="JVM的跨平台性"></a>JVM的跨平台性</h2><p>Java Virtual Machine简称JVM。各个操作系统之间存在着硬件、指令集的差异，而Java虚拟机的出现则屏蔽了这种差异性，我们只需在其中一个平台编写符合Java规范的代码，编译成为字节码，就可以通过不同平台版本的JVM运行这段字节码，实现“一处编译，处处运行”。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JVM在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途以及创建和销毁的时间。如下图所示。<br><img src="https://img-blog.csdnimg.cn/20201114183116339.png" alt="运行时数据区域"></p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，它是各个线程共享的内存区域。</p>
<h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>这是一块比较小的内存空间，用来存储当前线程所执行的字节码的行号，因此是线程私有的。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<h3 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>该区域也是线程私有，生命周期也与线程相同。它描述了Java方法执行的内存模型：每个方法被执行时都会同时创建一个栈帧，栈帧存储局部变量表、操作栈、动态链接、方法出口等信息，线程私有。<br>在JVM规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，但扩展到无法再申请足够的内存时会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>这个区域与虚拟机栈比较相似，不过虚拟机栈是为虚拟机执行Java方法服务的，而本地方法栈则是为使用到的操作系统方法服务的。</p>
<h3 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h3><p>Java堆是JVM所管理的内存中最大的一块内存区，是所有线程共享的内存区域。它的唯一目的就是存储对象实例，几乎所有的对象实例都在这里分配内存，它是GC所管理的主要区域，也叫“GC堆”。<br>Java堆中可细分为新生代和老年代，新生代还可以分为Eden、From和To，From和To空间统称Survivor空间。无论是哪个空间，存储的都是对象实例，只不过由于空间的特性不同，采用的垃圾收集算法也不同。</p>
<h2 id="垃圾收集（GC）"><a href="#垃圾收集（GC）" class="headerlink" title="垃圾收集（GC）"></a>垃圾收集（GC）</h2><p>在内存管理领域，C和C++既是拥有最高权力的皇帝，同时又是从事最基础工作的劳动人民，因为它既拥有每个对象的生杀大权，又担负着每一个对象生命从开始到终结的维护责任。而Java程序员不需要为每一个new操作去写配对的delete/free代码，因为有垃圾收集器自动对这些内存进行回收。</p>
<h3 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h3><p>垃圾收集器在对堆进行回收前，当然得要先确定哪些对象是否还存活，哪些要go die。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器加一；引用失效时，计数器减一。当计数器为0的时候就是不能再被使用的，这个对象就是要go die了。<br>这个方法实现比较简单，判定效率也比较高，但是有一个问题，它很难解决对象之间相互引用的问题。因此Java语言中没有选用这一方法来管理内存。</p>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>Java和C#都是使用这一方法来判定对象是否存活的。它的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，此时这个对象就是可回收的。<br>如下图，object5、object6、object7虽然是有关联的，但是它们到GC Roots是不可达的，所以它们被判定为是可回收的。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114183443761.jpg" alt="GC Roots"></p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块，然后把这一块全部清理掉。</p>
<p><img src="https://img-blog.csdnimg.cn/2020111418370090.png" alt="复制算法"></p>
<blockquote>
<p>优点：<br>内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针即可<br>缺点：<br>内存缩小为原来的一半</p>
</blockquote>
<h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>分为“标记”和“清除”两个阶段。在标记阶段，通过根搜索，标记所有从根节点开始的可达对象；然后在清楚阶段，清楚所有未被标记的对象。</p>
<p><img src="https://img-blog.csdnimg.cn/2020111418380812.png" alt="标记-清除算法"></p>
<blockquote>
<p>缺点：<br>1.效率问题，无论是标记还是清除过程，效率都不高；<br>2.空间问题，从上图就可以看出，标记清除后产生了大量不连续的内存碎片，当程序在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</blockquote>
<h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><p>分为“标记”和“整理”两个阶段。标记阶段仍和“标记-清除”算法一样，但是后续步骤直接清理可回收对象，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114183925804.png" alt="标记-整理算法"></p>
<blockquote>
<p>优点：<br>1.解决了内存碎片问题；<br>2.没有内存碎片，对象创建时内存分配也更快了。<br>缺点：<br>还是有一定的效率问题，标记和整理两个过程效率都不高。</p>
</blockquote>
<h4 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h4><p>根据对象存活周期的不同将内存分为几块，像Java堆就是分为新生代和老年代，然后根据各个年代的特点采用适当的收集算法。新生代采用复制算法，老年代采用“标记-清除”或“标记-整理”算法。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114184017593.png" alt="分代收集算法"></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>收集算法是内存回收的方法论，而垃圾收集器是内存回收的具体实现。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114184247458.jpg" alt="垃圾收集器"></p>
<h4 id="Serial（串行）收集器"><a href="#Serial（串行）收集器" class="headerlink" title="Serial（串行）收集器"></a>Serial（串行）收集器</h4><p>这种收集器是最基本、历史最悠久的收集器，它是一个单线程的收集器，使用复制算法，简单高效，Serial收集器由于没有线程交互的开销，专心做垃圾收集可以获得很高的单线程收集效率。它在进行垃圾收集时，必须暂停其它所有的工作线程，直到收集结束（“Stop The World”）。这就有点难受……想象一下你玩手机的时候隔一段时间就卡一卡，还卡很久……<br><img src="https://img-blog.csdnimg.cn/img_convert/afd01489ff7c43f20911847f7ee5ed53.png" alt="Serial收集器"></p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>实际上这个收集器就是Serial收集器的多线程版本，它除了多线程收集之外，其它与Serial没多大区别。这是第一款真正意义的并发收集器，它实现了让垃圾收集线程与用户线程同时工作。<br>ParNew收集器在单CPU的环境中不会比Serial收集器有更好的效果，而且由于存在线程交互的开销，该收集器可能回避Serial收集器表现更差。但是，随着可以使用的CPU数量的增加，它的表现它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用-XX:ParallerGCThreads参数设置。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/44b019d07e684205a84d8896216ed4c1.png" alt="ParNew收集器"></p>
<h4 id="Parallel（并行）-Scavenge-收集器"><a href="#Parallel（并行）-Scavenge-收集器" class="headerlink" title="Parallel（并行） Scavenge 收集器"></a>Parallel（并行） Scavenge 收集器</h4><p>这个收集器是一个并行的多线程新生代收集器，也是使用复制算法。它的关注点与其它收集器不同，其它收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量（吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间））。<br>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis以及直接设置吞吐量大小的 -XX:GCTTimeRatio参数。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</p>
<ul>
<li>此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/afd01489ff7c43f20911847f7ee5ed53.png" alt="Serial Old收集器"></p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge与Parallel Old组合。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/704ccbaa6bf0a2010625164999ed999d.png" alt="Parallel Old收集器"></p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。<br>从名字上（“Mark Sweep”）就可以看出它是基于“标记-清除”算法实现的，它的运作过程分为四个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li>并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。</li>
<li>重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/32e2b43663e2d0a4548446032f15491d.png" alt="CMS收集器"></p>
<blockquote>
<p>优点：<br>并发收集、低停顿<br>缺点<br>1.对CPU资源非常敏感<br>2.无法处理浮动垃圾<br>3.标记清楚算法导致产生较多空间碎片</p>
</blockquote>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li><strong>并行与并发</strong> G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li><strong>分代收集</strong> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li>
<li><strong>空间整合</strong> G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li><strong>可预测的停顿</strong> 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<hr>
<p>总的来说，这七种垃圾收集器的对比如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">收集器</th>
<th style="text-align:center">串行、并行or并发</th>
<th style="text-align:center">算法</th>
<th style="text-align:center">目标</th>
<th style="text-align:center">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Serial</td>
<td style="text-align:center">串行</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">单CPU环境下的Client模式</td>
</tr>
<tr>
<td style="text-align:center">Serial Old</td>
<td style="text-align:center">串行</td>
<td style="text-align:center">标记-整理</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td style="text-align:center">ParNew</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td style="text-align:center">Parallel Scavenge</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">吞吐量优先</td>
<td style="text-align:center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td style="text-align:center">Parallel Old</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">标记-整理</td>
<td style="text-align:center">吞吐量优先</td>
<td style="text-align:center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td style="text-align:center">CMS</td>
<td style="text-align:center">并发</td>
<td style="text-align:center">标记-清除</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td style="text-align:center">G1</td>
<td style="text-align:center">并发</td>
<td style="text-align:center">标记-整理+复制</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">面向服务端应用，将来替换CMS</td>
</tr>
</tbody>
</table>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个结点。其中验证、准备和解析三个部分统称为连接。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/612e4e344a18a9be5fbe8fde9e2ee05c.png" alt="类加载过程"></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，虚拟机需要完成三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。大致上会完成四个阶段的校验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。首先这时候进行内存分配的仅包括类变量而不包括实例变量，其次这里所说的初始值通常情况下是数据类型的零值，假设一个类变量定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int v = 321;</span><br></pre></td></tr></table></figure>
<p>那么变量v在准备阶段过后的初始值是0而不是321。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是类加载过程的最后一步，到初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。</p>
<h4 id="类加载器与类的唯一性"><a href="#类加载器与类的唯一性" class="headerlink" title="类加载器与类的唯一性"></a>类加载器与类的唯一性</h4><p>类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。通俗的说，JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。</p>
<p>这里的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>站在Java虚拟机的角度讲，只存在两种不同的类加载器：启动类加载器（Bootstrap ClassLoader）和所有其他的类加载器。启动类加载器使用C++实现，是虚拟机自身一部分，而其他的类加载器都由Java实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。<br>站在Java开发人员的角度来看，类加载器可以分为以下三种系统提供的类加载器：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong> 这个类加载器负责将存放在&lt;JAVA_HOME&gt;lib目录中的，或者被-Xbootclasspath参数所制定的路径中的，并且是被虚拟机识别的类库加载到虚拟机内存中。该加载器无法被Java程序直接引用</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong> 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong> 这个类加载器由sun.misc.Launcher@AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201114184531212.png" alt="双亲委派模型"></p>
<p>上图所展示的类加载器之间的层次关系就称为双亲委派模型。它要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。使用组合（Composition）关系来复用父加载器。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="HandsomeDong七里翔">
            
              <p class="site-author-name" itemprop="name">HandsomeDong七里翔</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HandsomeDong七里翔</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang大坑之循环goroutine闭包调用</title>
    <url>/2022/12/29/Golang%E5%A4%A7%E5%9D%91%E4%B9%8B%E5%BE%AA%E7%8E%AFgoroutine%E9%97%AD%E5%8C%85%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回顾整个2022，突然发现我一篇博客都没写，趁着还没2022还没过去，赶紧<del>水一篇博客</del> 分享一下我最近学习到的一些东西，这次的主题是“Golang大坑之循环goroutine闭包调用”，大家就当小故事来看吧。<br><img src="https://s2.loli.net/2023/07/18/LvX3ADzcOTSGIVE.jpg" alt="躺好，听我讲故事"></p>
<h1 id="小美又写了bug"><a href="#小美又写了bug" class="headerlink" title="小美又写了bug"></a>小美又写了bug</h1><p>仔细看，这个女孩叫小美，她最近刚入职某Go大厂，从Java转了Go，小美入职仅仅花了半天就学完了Go语法，然后三天写了5个bug，隔三差五就被leader小帅叫到会议室臭骂。<br><img src="https://s2.loli.net/2023/07/18/jbJHKo89QlLeGDF.gif" alt="小美"><br>这不，正当小美写bug写得起劲，小帅又过来拍了拍小美肩膀：“小美，来下会议室”。<br><img src="https://s2.loli.net/2023/07/18/9MyjaQRfYD4btHi.png" alt="小美来下会议室"><br>一来到会议室，小帅直接把笔记本拍到小美脸上：“看看你干的好事。”<br>笔记本上面是小美的提交记录，上面有这么一段代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"打工人%d号\n"</span>, num)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小美看完表示很委屈：“这有什么毛病吗？这里一共开了十个协程，每个协程打印的编号都不一样，这里的输出应该是下面这样啊？出什么问题了吗？”<br>小美预期的结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打工人9号</span><br><span class="line">打工人2号</span><br><span class="line">打工人3号</span><br><span class="line">打工人0号</span><br><span class="line">打工人1号</span><br><span class="line">打工人5号</span><br><span class="line">打工人7号</span><br><span class="line">打工人8号</span><br><span class="line">打工人4号</span><br><span class="line">打工人6号</span><br></pre></td></tr></table></figure></p>
<p>小帅一巴掌甩小美脸上：“要不你看看运行结果？”<br><img src="https://s2.loli.net/2023/07/18/ki8THV2BS59mp3j.png" alt="一巴掌"><br>小美运行了一下，结果让她大吃一斤翔。<br><img src="https://s2.loli.net/2023/07/18/uH72A3kwbyYTBpG.png" alt="运行结果"><br>面对这个结果，坚强的小美也落下了泪，她实在不明白为什么会这样。<br><img src="https://s2.loli.net/2023/07/18/PUwFegCSKybEuOp.jpg" alt="落泪的小美"></p>
<h1 id="小翔看出问题所在"><a href="#小翔看出问题所在" class="headerlink" title="小翔看出问题所在"></a>小翔看出问题所在</h1><p>谁也没有注意到，此时坐在会议室角落旁的小翔缓缓站了起来：“真相只有一个！”<br><img src="https://s2.loli.net/2023/07/18/9peBGu6UAgKX3tM.png" alt="小翔登场"><br>小翔继续说：“这是Golang新手及其容易犯的一个错误！<strong>你这里的goroutine执行了闭包内的程序，而闭包内直接引用了num变量，这个值并没有被保存到goroutine栈中，这样写会导致for循环结束后才执行goroutine多线程操作，所以你看，很多个协程打印的编号都是9，即for循环结束后协程才运行，这个时候num值其实指向了最后一个元素。当然，有个别协程打印的不是9，因为它们运行得比较早。</strong> 这样写及其容易窜数据，产生严重bug！”</p>
<p><strong>小帅一巴掌甩小翔脸上：“还TM装逼？快给我修bug。”</strong><br><img src="https://s2.loli.net/2023/07/18/7QXlSIWFbunADCv.jpg" alt="逼都让你装完了"></p>
<h1 id="小翔的解决方案"><a href="#小翔的解决方案" class="headerlink" title="小翔的解决方案"></a>小翔的解决方案</h1><p>小翔不愧是小翔，是见过各种大场面的男人，只见他不慌不忙给出了几种解决方案。</p>
<h2 id="正确写法1：不使用闭包"><a href="#正确写法1：不使用闭包" class="headerlink" title="正确写法1：不使用闭包"></a>正确写法1：不使用闭包</h2><p>既然闭包有问题，那我们不使用闭包不就行了？多大点事啊？<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="built_in">print</span>(num)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"打工人%d号\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正确写法2：循环内定义新变量"><a href="#正确写法2：循环内定义新变量" class="headerlink" title="正确写法2：循环内定义新变量"></a>正确写法2：循环内定义新变量</h2><p>由于循环内定义的变量在循环遍历过程中是不共享的，所以我们可以在循环内再定义新变量。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		num := num</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"打工人%d号\n"</span>, num)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正确写法3：闭包传参（优雅，推荐）"><a href="#正确写法3：闭包传参（优雅，推荐）" class="headerlink" title="正确写法3：闭包传参（优雅，推荐）"></a>正确写法3：闭包传参（优雅，推荐）</h2><p>使用闭包时，我们还是尽量使用闭包传参，避免直接在闭包内使用外部的变量，比较容易出错。我个人认为这样写起来会比较优雅，推荐这种写法。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"打工人%d号\n"</span>, num)</span><br><span class="line">		&#125;(num)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>上面3种写法都会得到正确的结果<br><img src="https://s2.loli.net/2023/07/18/Rhwtgy1VmQq65sp.png" alt="运行结果"></p>
<h1 id="小翔的静态扫描工具"><a href="#小翔的静态扫描工具" class="headerlink" title="小翔的静态扫描工具"></a>小翔的静态扫描工具</h1><h2 id="怎么从根源上避免这个问题"><a href="#怎么从根源上避免这个问题" class="headerlink" title="怎么从根源上避免这个问题"></a>怎么从根源上避免这个问题</h2><p>解决完了这个bug之后，leader小帅的脸色也有所好转，然后问了问小翔：“既然新手都比较容易犯这个错误，那我们有没有什么办法或手段来尽量让后面入职的同学少犯甚至不犯这个错误呢？换句话说，<strong>怎么从根源上避免出现这个问题</strong>？”<br><img src="https://s2.loli.net/2023/07/18/MfEN1ryj9IKbJC4.png" alt="怎么从根源上避免这个问题"><br>小翔推了推眼镜，冷静回答：“这个简单，回头我出个《Golang大坑》系列文档，让入职转Golang的新同学都看一下这个文档，他们就不会犯这个错误了！”<br><img src="https://s2.loli.net/2023/07/19/JxfvHYz5siP8hkA.jpg" alt="小帅推眼镜"><br>小帅直接就是一巴掌：“其实，我对你是有点失望的。你这个职级，不是把事情做完就可以的。你需要有体系化思考的能力。你做的事情，他的价值点在哪里？你是否作出了壁垒，形成了核心竞争力？你做的事情，和公司内其他团队的差异化在哪里？你的事情，是否沉淀了一套可复用的物理资料和方法论？为什么是你来做，其他人不能做吗？你需要有自己的判断力，而不是我说什么你就做什么…………（省略一千字）<strong>你确定你写个文档大家就会去看，就能遵守这一套约定？</strong>”<br><img src="https://s2.loli.net/2023/07/19/fQA2MdKrhJmBYgn.jpg" alt="小帅装逼"></p>
<h2 id="静态扫描工具"><a href="#静态扫描工具" class="headerlink" title="静态扫描工具"></a>静态扫描工具</h2><p>小翔这次终于是忍不住了，直接甩出了他的终极大招 – 静态扫描工具，缓缓说道：<strong>“这个是我写的Golang静态扫描工具，名叫 </strong>xianggolint<strong>，我刚刚加上了一个新规则：loopgoroutinecheck，它能扫描出循环内goroutine闭包直接引用循环index、value、key的代码，这种代码都是有问题的，Github 链接点<a href="https://github.com/HandsomeDong/xianggolint" target="_blank" rel="noopener">这里</a>，具体的使用方法可以看 readme 文档，以下是测试的扫描结果，可以看到扫描结果显示某个文件的第 12 行代码是有问题的，提示信息非常清晰。如果我们的CI/CD做得比较完善的话，我们还能将这种静态扫描工具接入到上面，在MR的时候进行扫描，扫出问题时就block进程，并提示该问题，这样我们就能在代码合入的阶段防止问题代码合入主分支啦！</strong>”<br><img src="https://s2.loli.net/2023/07/19/n8RsUdqv19WIZ7P.png" alt="代码"><br><img src="https://s2.loli.net/2023/07/19/6wmpHsRQBC1Z4ug.png" alt="代码"><br>小翔此时心里默默说：“今天这个装逼王，我当定了！”<br><img src="https://s2.loli.net/2023/07/19/jkBn7hNmvOAC4ZV.png" alt="小翔装逼王"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>循环goroutine闭包不能直接使用循环的index、key、value，因为这些变量没有被保存到goroutine栈中，比如以下代码，三个循环内的goroutine都不会得到我们所预期的结果。</strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"slice index: %d\n"</span>, index)</span><br><span class="line">			fmt.Printf(<span class="string">"slice value: %d\n"</span>, value)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"1"</span>: <span class="string">"1"</span>, <span class="string">"2"</span>: <span class="string">"2"</span>, <span class="string">"3"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"map key: %s\n"</span>, key)</span><br><span class="line">			fmt.Printf(<span class="string">"map value: %s\n"</span>, value)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"range i: %d\n"</span>, i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Microsecond * <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>我写了个静态扫描工具，针对这种代码写了相应的规则，能扫描出问题，欢迎使用，Github地址：<a href="https://github.com/HandsomeDong/xianggolint" target="_blank" rel="noopener">https://github.com/HandsomeDong/xianggolint</a></strong></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>高并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8 HashMap源码理解</title>
    <url>/2020/11/14/JDK8-HashMap%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">最近本翔再次认真阅读了HashMap的源码，总结一下自己的一些理解，希望对大家能有点帮助。</font></p>
<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><p>HashMap的数据结构是数组+链表，数组里面是一个个Node，在JDK8中加入了红黑树。HashMap根据存入的对象的hash跟数组长度取模得出下标，如果发生了哈希冲突，则新插入的键值对会放到上一个节点的后面，形成链表。当链表长度超过8且数组长度也不小于64时会转为红黑树，同理，链表长度小于6时会再次变回链表。数组里的每个存储空间，我们称为桶(bucket)。<br><img src="https://s2.loli.net/2023/07/19/FLEQBtTJXvwnz1l.png#pic_center" alt="HashMap内部"></p>
<h2 id="1-1-Node"><a href="#1-1-Node" class="headerlink" title="1.1 Node"></a>1.1 Node</h2><p>Node封装了key和value，我们使用put方法塞进去key和value其实都存到了Node里面，看看Node里面的成员变量有哪些。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;K,V&gt; <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;K,V&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ………………略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到里面有四个成员</p>
<blockquote>
<p>hash值：即键的散列值<br>key：就是我们put进去的那个键了<br>value：就是我们put进去的那个值了<br>next：下一个节点</p>
</blockquote>
<h2 id="1-2-重要参数"><a href="#1-2-重要参数" class="headerlink" title="1.2 重要参数"></a>1.2 重要参数</h2><p>HashMap里面定义了一些比较重要的参数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;    <span class="comment">//初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;    <span class="comment">//负载因子，当map里面的node数量大于 threshold = loadFactor * capacity时，就会扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;    <span class="comment">//桶的树化阈值，转为红黑树的哈希冲突数量阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;    <span class="comment">//桶的链表还原阈值，转为链表的哈希冲突数量阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;    <span class="comment">//最小树形化容量阈值，当哈希表中的容量即数组长度不小于该值时，树形化链表</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>1.初始容量和加载因子我们在实例化HashMap的时候是可以定义的。当 元素数量 &gt; 容量*加载因子 时，数组就会扩容。<br>2.当桶里面的 链表长度 &gt; TREEIFY_THRESHOLD 且 桶数组长度 &gt; MIN_TREEIFY_CAPACITY 时，链表就会转换为红黑树。</p>
</blockquote>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><h2 id="2-1-扰动函数"><a href="#2-1-扰动函数" class="headerlink" title="2.1 扰动函数"></a>2.1 扰动函数</h2><p>没仔细看源码前，我一直以为计算桶下标的时候值直接用键的hashCode跟数组容量相与得出的下标，现在仔细一看才发现事情没那么简单。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == null) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到扰动函数里面把hashCode右移了16位再与原hashCode进行了异或操作，即用自己的高16位和低16位进行了异或。这样能增加随机性，让数据元素更散列，减少碰撞。</p>
<h2 id="2-2-插入"><a href="#2-2-插入" class="headerlink" title="2.2 插入"></a>2.2 插入</h2><p>简单来说，插入键值对的时候，先通过键的哈希值计算出下标，然后再把数据存放到数组中。不多BB，直接放源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, boolean onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               boolean evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果数组未初始化，则先初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == null || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果桶里没数据，直接新建一个Node，并把桶指向这个Node</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    <span class="comment">//桶里有数据再做处理</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//键值和键散列值都和桶里的第一个Node键值和键hashCode一样，直接把e指向这个Node，准备后面直接替换值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果是TreeNode对象，则调用红黑树插入值的方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//即不是树节点，且第一个Node也不是要找的Node，那就准备遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//遍历链表且统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">            	<span class="comment">//遍历完链表都没有这个key，那就在链表后面插入新节点吧</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    <span class="comment">//链表长度大于阈值的话就转为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到key，结束遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//e不为空则表示链表里包含有要插入的键值对，直接替换值就好了</span></span><br><span class="line">        <span class="keyword">if</span> (e != null) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//元素数量超过threshold时就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤如下：</p>
<blockquote>
<p>1.检查桶数组是否为空，为空则resize()初始化<br>2.计算下标，用桶数组长度 - 1跟键的哈希值相与，即(length - 1) &amp; hash 计算下标，看桶是否为空，为空就直接把Node存进桶中<br>3.如果桶里第一个Node的key和当前的key一样，直接将桶指向现在的Node<br>4.如果Node是树节点，就调用红黑树的插入方法<br>5.如果以上两种情况都不是，则需要遍历该链表，找到对应的key替换值或者没有key就往链表尾部插入新Node<br>6.所有元素处理完成后，判断size是否超过阈值 threshold，是则resize()扩容</p>
</blockquote>
<h2 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h2><p>查找就比较简单，就计算出数组下标，到桶里面看看是红黑树还是链表还是null，再拿数据。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//桶里有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != null) &#123;</span><br><span class="line">        <span class="comment">//如果桶里第一个就是要找的，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != null) &#123;</span><br><span class="line">        	<span class="comment">//树节点，调红黑树的查询方法</span></span><br><span class="line">            <span class="keyword">if</span> (first instanceof TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-树形化"><a href="#2-4-树形化" class="headerlink" title="2.4 树形化"></a>2.4 树形化</h2><p>由于从链表中查找数据的时间复杂度是O(n)，所以如果插入的键值对，发生哈希碰撞太多而导致链表过长的时候，那性能是非常差的。所以在JDK8中，链表长度大于8且桶容量不小于64时，链表会树形化，即转为红黑树。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//可以看到，如果桶数组容量小于64时，就算链表长度大于8，也只会扩容而不会把链表转为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	<span class="comment">//注意，这里只是把普通节点转成了树节点，现在还不是红黑树</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">            <span class="keyword">if</span> (tl == null)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != null)</span><br><span class="line">        	<span class="comment">//这里才是转红黑树，红黑树内容略多，就不在这篇博客详细总结了</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-扩容"><a href="#2-5-扩容" class="headerlink" title="2.5 扩容"></a>2.5 扩容</h2><p>扩容可以有效避免有太多的哈希碰撞而导致的桶内数据过多的情况。桶数组容量 * 负载因子大于元素数量时，HashMap就会扩容，把数组容量扩大一倍。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == null) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//容量不为空，即已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">//容量达到 2^30 ，不会再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容量增加一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//初始化新的桶数组</span></span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != null) &#123;</span><br><span class="line">    	<span class="comment">//遍历旧的桶数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//桶里面有数据，准备迁移</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                <span class="comment">//如果桶里只有一个节点的话，直接把新桶指向这个节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果桶里指向的是树节点，则调用红黑树的拆分操作</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//桶里的链表不止一个节点，则需要遍历链表一个个迁移</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//这里用哈希跟旧数组长度相与，计算出该节点是放在高位桶还是低位桶</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != null);</span><br><span class="line">                    <span class="comment">//把新桶指向链表头节点，数据迁移完成</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结扩容操作步骤，其实主要就以下几个步骤：</p>
<blockquote>
<p>1.没初始化就初始化，容量达到MAXIMUM_CAPACITY即2^30就不扩容了<br>2.新建桶数组，容量为旧的桶数组的2倍<br>3.遍历旧数组的所有桶，桶里链表只有一个数据就直接迁移，是树节点就调用红黑树的拆分方法，链表不止一个数据就遍历链表<br>4.由于新桶数组容量是原来的两倍，所以原本在同一个桶中的数据迁移到新数组中时，是有可能放在不同的两个桶中的。一个是低位桶，下标值和原来的一样，一个是高位桶，下标值和原来的差值为旧桶数组的容量，通过 hash&amp;oldCap 是否等于0可以判断这个节点是在高位桶还是低位桶</p>
</blockquote>
<p>为什么 (hash&amp;oldCap==0) 可以判断一个节点是在高位桶还是低位桶呢？</p>
<blockquote>
<p>一个节点的数组下标，是通过它的键的hash跟数组容量取模计算得来的，所以同一个桶上的数据，要么它们的hash相等，要么它们的hash相差 2^n 个数组容量。<br>比如两个哈希值分别为13和5的键，插进数组长度为8的桶数组里，1101&amp;0111 和 0101&amp;0111 计算得到的下标都是0101，即5。当扩容后，数组长度为16，而这时再计算下标时， 就变成了 1101&amp;1111和0101&amp;1111，最终的结果分别为13和5，它们相差8。哈希值为5的节点扩容后仍然在下标值为5的桶上，而哈希值为13的节点已经迁移到了下标值为8的桶上了。<br>其实不难发现，通过位于运算计算下标时，扩容前的0111和扩容后的1111只相差第四位的那个1，由于哈希值为13的第四位原本是1，而哈希值为5的第四位原本是0，当位于运算的值有0111变成1111时，第四位也参与了运算，才导致了扩容后的它们得出的下标值会不同。所以我们可以直接用1000跟hash进行相与，看看它的第四位是1还是0就可以知道它是在高位桶还是低位桶了。</p>
</blockquote>
<h1 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h1><h2 id="3-1-桶数组长度为什么总是2的n次方"><a href="#3-1-桶数组长度为什么总是2的n次方" class="headerlink" title="3.1 桶数组长度为什么总是2的n次方"></a>3.1 桶数组长度为什么总是2的n次方</h2><blockquote>
<p>计算效率更高，计算更方便。<br>取模(%)操作中如果除数是2的幂次，则等价于与其除数减一的与(&amp;)操作（前提是length是2的n次方）。所以可以从源码中看到，计算数组下标是通过 hash &amp; (length - 1) 来计算的。而且这样使扩容后计算新位置会更方便，从扩容源码中可以看到判断一个节点扩容后的数组下标是在高位桶还是低位桶时，直接用hash跟旧桶数组容量相与即可判断，并在如果是高位桶，直接用下标加上旧数组长度即可拿到高位桶的下标。</p>
</blockquote>
<h2 id="3-2-HashMap的参数loadFactor，它的作用是什么？"><a href="#3-2-HashMap的参数loadFactor，它的作用是什么？" class="headerlink" title="3.2 HashMap的参数loadFactor，它的作用是什么？"></a>3.2 HashMap的参数loadFactor，它的作用是什么？</h2><blockquote>
<p>其实从源码中可以看得很清楚了，它其实是表示HashMap里面数组所能承受的拥挤程度，影响hash操作到同一个数组位置的概率。默认的loadFactor是0.75，当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，在HashMap的构造器中可以定制loadFactor。</p>
</blockquote>
<h2 id="3-3-HashMap从JDK7到JDK8的变化。"><a href="#3-3-HashMap从JDK7到JDK8的变化。" class="headerlink" title="3.3 HashMap从JDK7到JDK8的变化。"></a>3.3 HashMap从JDK7到JDK8的变化。</h2><blockquote>
<p>1.树形化<br>首先肯定就是新增了红黑树啦，JDK7及之前桶中只有链表一种数据结构，JDK8中桶内元素大于8且数组容量不小于64时便会把桶内链表转为红黑树。<br>2.hash计算方式不同<br>JDK7的扰动函数，前前后后进行了四次扰动。而JDK8简化了这一操作，只是对高低位做了异或。<br>3.扩容操作中，下标的计算方法不一样。<br>可以从JDK8源码中看到resize()里面，判断节点是高位桶还是低位桶，是高位桶的话，直接用旧的下标加上旧的数组容量即可。但是JDK7中不是这样的，JDK7的扩容操作需要对节点重新计算下标。<br>4.发生哈希碰撞时，插入链表中的方法不一样。<br>JDK8里的HashMap插入元素时，用的是尾插法，但是JDK7里用的是头插法。在进行扩容操作迁移元素时也是如此，这就导致JDK7的HashMap在多线程进行扩容操作时，有可能会出现死锁问题！这里就不详细描述JDK7HashMap的死锁问题了，后面会专门出篇博客翔谈该问题。（不要问我为什么是“翔谈”不是“详谈”，我叫七里翔）</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK7HashMap多线程扩容导致的死循环问题</title>
    <url>/2020/11/14/JDK7HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A9%E5%AE%B9%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">JDK8以前的HashMap，多线程扩容的时候可能会出现死循环，这个问题在JDK8得到了修复。本翔看了大半天JDK7HashMap扩容源码找这个问题，所以写篇博客记录记录。</font></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>先来看看JDK7的HashMap扩容相关源码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//扩容</span><br><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">       int newCapacity = newTable.length;</span><br><span class="line">       //遍历旧桶数组</span><br><span class="line">       for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">           while(null != e) &#123;</span><br><span class="line">           	//先记录下一次循环要插入的节点</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               if (rehash) &#123;</span><br><span class="line">                   e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">               //计算新下标</span><br><span class="line">               int i = indexFor(e.hash, newCapacity);</span><br><span class="line">               //下面这两步很明显了，头插法。即先拿到桶原本指向的节点，把要插入的节点的next指向它，然后再把桶指向这个要插入的节点</span><br><span class="line">               e.next = newTable[i];</span><br><span class="line">               newTable[i] = e;</span><br><span class="line">               //next记录了旧数组旧链表里的下一个节点，现在把e指向它，准备下次循环把它插到新桶</span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 transfer 方法用的是头插法，我们重点注意以下几个步骤：</p>
<blockquote>
<p>1.Entry&lt;K,V&gt; next = e.next;     next指向旧链表中的下一个节点<br>2.e.next = newTable[i];      把新链表的头结点摘下来放到将要插入的节点的尾部<br>3.newTable[i] = e;        插入节点，即把桶指向e<br>4.e = next;        把e指向next，准备继续插入下一个节点</p>
</blockquote>
<h1 id="多线程扩容"><a href="#多线程扩容" class="headerlink" title="多线程扩容"></a>多线程扩容</h1><p>单线程的情况下扩容，是没什么问题的，我们直接来一步步分析多线程扩容的时候会出现什么问题。</p>
<blockquote>
<p>假如扩容前的数组和链表是这样的，数组里有2个桶，桶1里有三个节点，它们的键分别为3、7、5。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/19/blEqv2TKHC8zY7P.png#pic_center" alt="扩容前"></p>
<blockquote>
<p>1 现在有两个线程同时扩容这个数组。假如线程一先拿到了cpu资源，执行完了 <strong>Entry&lt;K,V&gt; next = e.next;</strong> 这一步后，e指向3，next指向7。<br>这时CPU资源交给了线程二，好家伙，线程二啪啦啪啦啪啦一下子就把整个链表都迁移了过去，直接扩容完成。<br>这个时候旧数组、链表和两个线程的状态是这样的。<br><img src="https://s2.loli.net/2023/07/19/o47McDelJqGOxyA.png#pic_center" alt="线程二扩容完成"></p>
</blockquote>
<blockquote>
<p>2 现在轮到线程一继续执行了。线程一一顿操作猛如虎，执行完第一次循环后，把3插了进去，然后把next赋给了e，还记得在线程二执行的时候，线程一的next是7吗？现在e指向的节点就是7，准备下一次循环插入7。第一次循环过后变成了这样：<br><img src="https://s2.loli.net/2023/07/19/5yFvHUxTd697JDj.png#pic_center" alt="第一次循环结束"></p>
</blockquote>
<blockquote>
<p>3 下次循环一开始，<strong>Entry&lt;K,V&gt; next = e.next</strong> 直接把next指向3。问题不大，没毛病。现在继续执行下去，把7的next指向3，然后再把桶指向7，即用头插法插入了7。执行完第二次循环后如下图，现在问题已经差不多出来了，执行完此次循环后，e指向了3，但是3已经被插入了，继续执行下去会怎么样呢？<br><img src="https://s2.loli.net/2023/07/19/efA5nEC3gvOi4jr.png#pic_center" alt="第二次循环结束"></p>
</blockquote>
<blockquote>
<p>4 这次循环执行情况是这样的<br>Entry&lt;K,V&gt; next = e.next;    现在e是3，而3的next是null，所以next指向了null<br>e.next = newTable[i];        这一步把3的next指向了7，因为桶现在是指向7的<br>newTable[i] = e;            把桶指向3<br>e = next;        由于next是null了，所以e指向了null，跳出了while进行后面的for循环<br>现在问题出来了，3的next指向了7，而7的next原本就指向3，情况如下图：<br><img src="https://s2.loli.net/2023/07/19/hHXCscelu493RST.png#pic_center" alt="第三次循环结束出大问题"></p>
</blockquote>
<p>显而易见，环形链表出现，这个时候如果我们再去做一些查询，查到这个桶3上面来的话，遍历的时候就出现了死循环，直接出不去了，出大问题……<br>还好JDK8修复了这个死循环问题。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Write-up: CTFHUB web之Git泄露</title>
    <url>/2025/08/18/Write-up-CTFHUB-web%E4%B9%8BGit%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>git应该是最主流的版本控制工具了，但是如果配置不当，可能会不小心把 .git 文件夹直接部署到生产环境。当然，这都2025了，不太可能会有开发出现这种错误了……</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Githack"><a href="#Githack" class="headerlink" title="Githack"></a>Githack</h2><p>项目地址：<a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">https://github.com/lijiejie/GitHack</a><br>这是一个.git泄露利用脚本，可以通过.git文件夹下的文件，重建还原工程源代码。</p>
<p>下载后，用python2就可以运行该脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python GitHack.py http://www.openssl.org/.git/</span><br></pre></td></tr></table></figure></p>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>ctfhub 的 git 泄露一共有3道，先来做第一道：Log</p>
<p><img src="https://s2.loli.net/2025/08/18/Pg46BCWhMVmY3al.png" alt="image.png"></p>
<p>打开后就一个页面，显示“Where is flag?”<br><img src="https://s2.loli.net/2025/08/18/cktFWeN5zHpI1jQ.png" alt="image.png"></p>
<p>直接用脚本下载并重建工程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 GitHack.py http://challenge-4b71d7d837e22605.sandbox.ctfhub.com:10800/.git</span><br></pre></td></tr></table></figure></p>
<p><img src="https://s2.loli.net/2025/08/18/dKW8nlYpC6hax9S.png" alt="image.png"></p>
<p>全局搜索 “ctfhub” 或者 “flag”，在源代码中搜不到，但是在git log相关文件中能看到提交记录有端倪，应该是添加了 flag 后又删掉了。</p>
<p><img src="https://s2.loli.net/2025/08/18/5QATtId8aDZfn6o.png" alt="image.png"></p>
<p>用 git reset 回滚到 “add flag” 那一次提交后再全局搜索 “ctfhub” 或者 “flag”，可以在一个 txt 文件里找到 flag 了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard fa0ee775a01e795f67ef4cb9d816ed52b0321473</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/18/eI5RoP8OFhJXl4d.png" alt="image.png"></p>
<h2 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h2><p>前面的步骤和上面的一样，不过这次的txt文件里可就没有flag了<br><img src="https://s2.loli.net/2025/08/18/eHl9vw8rIpbZ7hy.png" alt="image.png"></p>
<p>但是在 .git/logs/refs/stash 里面看到有个 flag 的日志，stash 是什么可以看这里 <a href="https://git-scm.com/docs/git-stash/zh_HANS-CN" target="_blank" rel="noopener">https://git-scm.com/docs/git-stash/zh_HANS-CN</a><br><img src="https://s2.loli.net/2025/08/18/s5igbSB9RnMH3xl.png" alt="image.png"></p>
<p>用 git stash list 看看暂存的修改<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></p>
<p><img src="https://s2.loli.net/2025/08/18/Q2EPmrHX3qIdA1S.png" alt="image.png"></p>
<p>用 git stash pop 把暂存的修改还原后，可以看到txt文件里的flag了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></p>
<p><img src="https://s2.loli.net/2025/08/18/m2K9CVPoBARfTlZ.png" alt="image.png"></p>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>前几步步骤仍然和上面一样，但是txt文件直接就有flag了……<br>突然想到这几道题其实不应该直接用 Githack 工具还原工程，而是应该先用 dirsearch 扫描网站泄露的目录，扫出来发现有 .git 文件夹后，再用 Githack 工具还原工程，毕竟在真实的场景下，我们是不知道网站会有什么安全风险的，后续再更新一下用 dirsearch 该怎么做。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>碰到 git 信息泄露的情况，可以使用 Githack 工具还原工程，flag 可能存在于旧版本、别的分支、暂存区中，得细心找找！</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
        <category>Writeup</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web安全</tag>
        <tag>Writeup</tag>
        <tag>信息泄露</tag>
        <tag>Git泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>Git恢复本地分支</title>
    <url>/2019/04/27/Git-%E6%81%A2%E5%A4%8D%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>一般来说，我们开发新功能都会在develop分支下新建一个分支，命名为 <strong>feature/新功能</strong>，测试没问题后再合并到develop推到远程分支。由于我是新手，老大通常要我先别合并，先推到远程的新分支下等他review没问题后再合并到develop。</p>
<p>有强迫症的我，看到本地太多分支就不舒服，推到远程分支后直接就删掉本地分支，只留master和develop两个分支，干干净净舒舒服服！！！</p>
<p><img src="https://i.loli.net/2019/04/27/5cc34c7e105f4.png" alt="帅字贯穿了我的一生"></p>
<p>万万没想到没想到老大也喜欢干干净净舒舒服服，但他不仅喜欢本地干干净净，也喜欢远程分支干干净净……然后今天早上问我这个功能的代码推到哪个分支了，我看了半天好像也找不到，老大说可能是他误删了……我……</p>
<p><img src="https://i.loli.net/2019/04/27/5cc34c7e15923.png" alt="枯了"></p>
<p>原谅我是个菜鸡，Git可以恢复本地分支我都唔鸡，老大提醒我后我赶紧看了一下如何恢复本地分支，没想到如此简单！我只知道怎么在现有分支回滚代码，万万没想到连分支都能恢复！</p>
<p><img src="https://i.loli.net/2019/04/28/5cc59b0db9ebe.png" alt="流下了没技术的泪水"></p>
<p><strong>仅需两步即可找回丢失分支！</strong><br>1.git log -g 找到删除分支前的commit_id<br>2.git branch recover commit_id  把代码恢复到新分支recover下</p>
<h1 id="下面来演示全过程"><a href="#下面来演示全过程" class="headerlink" title="下面来演示全过程"></a>下面来演示全过程</h1><h2 id="1-新建并切换到新分支test"><a href="#1-新建并切换到新分支test" class="headerlink" title="1.新建并切换到新分支test"></a>1.新建并切换到新分支test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/04/27/5cc34a8b4584c.png" alt="新建并切换到新分支test"></p>
<h2 id="2-新建文件随便写点东西"><a href="#2-新建文件随便写点东西" class="headerlink" title="2.新建文件随便写点东西"></a>2.新建文件随便写点东西</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim test.txt</span><br></pre></td></tr></table></figure>
<p>我随便写了个 “test”</p>
<p><img src="https://i.loli.net/2019/04/27/5cc34a8b487e8.png" alt="新建文件随便写点东西"></p>
<h2 id="3-提交代码"><a href="#3-提交代码" class="headerlink" title="3.提交代码"></a>3.提交代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Add test.txt&quot;</span><br><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>可以看到现在有master和test两个分支</p>
<p><img src="https://i.loli.net/2019/04/27/5cc34a8bb2edf.png" alt="提交代码"></p>
<h2 id="4-切换回master分支并删除test分支"><a href="#4-切换回master分支并删除test分支" class="headerlink" title="4.切换回master分支并删除test分支"></a>4.切换回master分支并删除test分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -D test</span><br><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>可以看到现在只有master一个分支了</p>
<p><img src="https://i.loli.net/2019/04/27/5cc34a8bcdea0.png" alt="删除分支"></p>
<h2 id="5-git-log-g查看提交记录"><a href="#5-git-log-g查看提交记录" class="headerlink" title="5.git log -g查看提交记录"></a>5.git log -g查看提交记录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -g</span><br></pre></td></tr></table></figure>
<p>可以从提交记录可以看到commit、commit的id及提交者等信息。通过conmit来找到你想要恢复的代码，所以一个好的commit很重要哦。</p>
<p><img src="https://i.loli.net/2019/04/27/5cc34a8be96b9.png" alt="查看提交记录"></p>
<h2 id="6-找到commit-id并恢复到新分支"><a href="#6-找到commit-id并恢复到新分支" class="headerlink" title="6.找到commit_id并恢复到新分支"></a>6.找到commit_id并恢复到新分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch recover d0bd911dcbe57eb4ff1c99dd03b42da34a75640a</span><br></pre></td></tr></table></figure>
<h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git checkout recover</span><br><span class="line">ls</span><br><span class="line">cat test.txt</span><br></pre></td></tr></table></figure>
<p>可以看到在recover分支和之前删除的test分支是一样的，文件一样，文件内容也一样，恢复分支成功！</p>
<p><img src="https://i.loli.net/2019/04/27/5cc34a8beb6a2.png" alt="查看结果"></p>
<p>所以一定要好好commit啊，不然不管是回滚代码还是恢复分支，光是找节点就能让你找半天！</p>
]]></content>
      <categories>
        <category>Git</category>
        <category>工作中的Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring @Autowire注入Map和List</title>
    <url>/2019/10/17/Spring-Autowire%E6%B3%A8%E5%85%A5Map%E5%92%8CList/</url>
    <content><![CDATA[<p>今天要实现一个需求，我们要同时使用阿里云和白山云的对象存储，在上传或者删除一些文件时，两个对象存储都要做同样的操作。由于是不同的平台，配置、SDK什么的都不一样，因此我写了一个接口让它们去实现，然后我再在service调用bean的方法去操作文件。本来还想用@Autowire和@Qualifier分别注入这两个bean再塞到一个list去调用它们，然后突然发现@Autowired能直接注入Map或List，把实现该接口的所有的bean塞到一个集合中，实在是太棒太灵活了！</p>
<p><img src="https://s2.loli.net/2023/07/19/Tln9VrfdFsKLq1o.jpg" alt="太棒了"></p>
<p>那么就不多BB了，直接上代码。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Cat implements Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, this is &quot; + this.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Dog implements Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, this is &quot; + this.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3><p>可以注入Map或者List，指定泛型是那个接口类型即可。下面是测试的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private List&lt;Animal&gt; animalList;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Map&lt;String, Animal&gt; animalMap;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        for (Animal animal : animalList) &#123;</span><br><span class="line">            animal.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = animalMap.keySet();</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            animalMap.get(key).sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>断点看了一下变量，可以看到在Map里面，key就是bean的名字。<br><img src="https://s2.loli.net/2023/07/19/uhYFMjNmke7BCvb.jpg" alt="测试断点"></p>
<p>下面是运行结果。</p>
<p><img src="https://s2.loli.net/2023/07/19/YzF3wbAU4k76BRu.jpg" alt="运行结果"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM基础</title>
    <url>/2019/07/22/JVM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="JVM基础知识"><a href="#JVM基础知识" class="headerlink" title="JVM基础知识"></a>JVM基础知识</h1><blockquote>
<p>最近看《深入理解Java虚拟机》学习到了一些JVM基础知识，主要了解了JVM运行时数据区域、GC以及类加载机制，现在来总结一下。</p>
</blockquote>
<h2 id="JVM的跨平台性"><a href="#JVM的跨平台性" class="headerlink" title="JVM的跨平台性"></a>JVM的跨平台性</h2><p>Java Virtual Machine简称JVM。各个操作系统之间存在着硬件、指令集的差异，而Java虚拟机的出现则屏蔽了这种差异性，我们只需在其中一个平台编写符合Java规范的代码，编译成为字节码，就可以通过不同平台版本的JVM运行这段字节码，实现“一处编译，处处运行”。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JVM在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途以及创建和销毁的时间。如下图所示。<br><img src="https://s2.loli.net/2023/07/19/xtwkZ395WSn41om.png" alt="运行时数据区域"></p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，它是各个线程共享的内存区域。</p>
<h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>这是一块比较小的内存空间，用来存储当前线程所执行的字节码的行号，因此是线程私有的。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<h3 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>该区域也是线程私有，生命周期也与线程相同。它描述了Java方法执行的内存模型：每个方法被执行时都会同时创建一个栈帧，栈帧存储局部变量表、操作栈、动态链接、方法出口等信息，线程私有。<br>在JVM规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，但扩展到无法再申请足够的内存时会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>这个区域与虚拟机栈比较相似，不过虚拟机栈是为虚拟机执行Java方法服务的，而本地方法栈则是为使用到的操作系统方法服务的。</p>
<h3 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h3><p>Java堆是JVM所管理的内存中最大的一块内存区，是所有线程共享的内存区域。它的唯一目的就是存储对象实例，几乎所有的对象实例都在这里分配内存，它是GC所管理的主要区域，也叫“GC堆”。<br>Java堆中可细分为新生代和老年代，新生代还可以分为Eden、From和To，From和To空间统称Survivor空间。无论是哪个空间，存储的都是对象实例，只不过由于空间的特性不同，采用的垃圾收集算法也不同。</p>
<h2 id="垃圾收集（GC）"><a href="#垃圾收集（GC）" class="headerlink" title="垃圾收集（GC）"></a>垃圾收集（GC）</h2><p>在内存管理领域，C和C++既是拥有最高权力的皇帝，同时又是从事最基础工作的劳动人民，因为它既拥有每个对象的生杀大权，又担负着每一个对象生命从开始到终结的维护责任。而Java程序员不需要为每一个new操作去写配对的delete/free代码，因为有垃圾收集器自动对这些内存进行回收。</p>
<h3 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h3><p>垃圾收集器在对堆进行回收前，当然得要先确定哪些对象是否还存活，哪些要go die。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器加一；引用失效时，计数器减一。当计数器为0的时候就是不能再被使用的，这个对象就是要go die了。<br>这个方法实现比较简单，判定效率也比较高，但是有一个问题，它很难解决对象之间相互引用的问题。因此Java语言中没有选用这一方法来管理内存。</p>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>Java和C#都是使用这一方法来判定对象是否存活的。它的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，此时这个对象就是可回收的。<br>如下图，object5、object6、object7虽然是有关联的，但是它们到GC Roots是不可达的，所以它们被判定为是可回收的。</p>
<p><img src="https://s2.loli.net/2023/07/19/83vrZykwUfn6EIY.jpg" alt="GC Roots"></p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块，然后把这一块全部清理掉。</p>
<p><img src="https://s2.loli.net/2023/07/19/QAXBEHLoWDl1bFI.webp" alt="复制算法"></p>
<blockquote>
<p>优点：<br>内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针即可<br>缺点：<br>内存缩小为原来的一半</p>
</blockquote>
<h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>分为“标记”和“清除”两个阶段。在标记阶段，通过根搜索，标记所有从根节点开始的可达对象；然后在清楚阶段，清楚所有未被标记的对象。</p>
<p><img src="https://s2.loli.net/2023/07/19/Ie6KCdnfT5lqcAg.webp" alt="标记-清除算法"></p>
<blockquote>
<p>缺点：<br>1.效率问题，无论是标记还是清除过程，效率都不高；<br>2.空间问题，从上图就可以看出，标记清除后产生了大量不连续的内存碎片，当程序在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</blockquote>
<h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><p>分为“标记”和“整理”两个阶段。标记阶段仍和“标记-清除”算法一样，但是后续步骤直接清理可回收对象，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://s2.loli.net/2023/07/19/AfUeJGiQbmVZuTs.webp" alt="标记-整理算法"></p>
<blockquote>
<p>优点：<br>1.解决了内存碎片问题；<br>2.没有内存碎片，对象创建时内存分配也更快了。<br>缺点：<br>还是有一定的效率问题，标记和整理两个过程效率都不高。</p>
</blockquote>
<h4 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h4><p>根据对象存活周期的不同将内存分为几块，像Java堆就是分为新生代和老年代，然后根据各个年代的特点采用适当的收集算法。新生代采用复制算法，老年代采用“标记-清除”或“标记-整理”算法。</p>
<p><img src="https://s2.loli.net/2023/07/19/6MDYeUNOuIHolhZ.webp" alt="分代收集算法"></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>收集算法是内存回收的方法论，而垃圾收集器是内存回收的具体实现。</p>
<p><img src="https://s2.loli.net/2023/07/19/Mm5K8VuB4S1jRpW.jpg" alt="垃圾收集器"></p>
<h4 id="Serial（串行）收集器"><a href="#Serial（串行）收集器" class="headerlink" title="Serial（串行）收集器"></a>Serial（串行）收集器</h4><p>这种收集器是最基本、历史最悠久的收集器，它是一个单线程的收集器，使用复制算法，简单高效，Serial收集器由于没有线程交互的开销，专心做垃圾收集可以获得很高的单线程收集效率。它在进行垃圾收集时，必须暂停其它所有的工作线程，直到收集结束（“Stop The World”）。这就有点难受……想象一下你玩手机的时候隔一段时间就卡一卡，还卡很久……</p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>实际上这个收集器就是Serial收集器的多线程版本，它除了多线程收集之外，其它与Serial没多大区别。这是第一款真正意义的并发收集器，它实现了让垃圾收集线程与用户线程同时工作。<br>ParNew收集器在单CPU的环境中不会比Serial收集器有更好的效果，而且由于存在线程交互的开销，该收集器可能回避Serial收集器表现更差。但是，随着可以使用的CPU数量的增加，它的表现它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用-XX:ParallerGCThreads参数设置。</p>
<h4 id="Parallel（并行）-Scavenge-收集器"><a href="#Parallel（并行）-Scavenge-收集器" class="headerlink" title="Parallel（并行） Scavenge 收集器"></a>Parallel（并行） Scavenge 收集器</h4><p>这个收集器是一个并行的多线程新生代收集器，也是使用复制算法。它的关注点与其它收集器不同，其它收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量（吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间））。<br>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis以及直接设置吞吐量大小的 -XX:GCTTimeRatio参数。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</p>
<ul>
<li>此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge与Parallel Old组合。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。<br>从名字上（“Mark Sweep”）就可以看出它是基于“标记-清除”算法实现的，它的运作过程分为四个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li>并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。</li>
<li>重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://s2.loli.net/2023/07/19/HhEvo1V3N6qOYjT.jpg" alt="CMS收集器"></p>
<blockquote>
<p>优点：<br>并发收集、低停顿<br>缺点<br>1.对CPU资源非常敏感<br>2.无法处理浮动垃圾<br>3.标记清楚算法导致产生较多空间碎片</p>
</blockquote>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li><strong>并行与并发</strong> G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li><strong>分代收集</strong> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li>
<li><strong>空间整合</strong> G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li><strong>可预测的停顿</strong> 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<hr>
<p>总的来说，这七种垃圾收集器的对比如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">收集器</th>
<th style="text-align:center">串行、并行or并发</th>
<th style="text-align:center">算法</th>
<th style="text-align:center">目标</th>
<th style="text-align:center">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Serial</td>
<td style="text-align:center">串行</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">单CPU环境下的Client模式</td>
</tr>
<tr>
<td style="text-align:center">Serial Old</td>
<td style="text-align:center">串行</td>
<td style="text-align:center">标记-整理</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td style="text-align:center">ParNew</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td style="text-align:center">Parallel Scavenge</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">吞吐量优先</td>
<td style="text-align:center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td style="text-align:center">Parallel Old</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">标记-整理</td>
<td style="text-align:center">吞吐量优先</td>
<td style="text-align:center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td style="text-align:center">CMS</td>
<td style="text-align:center">并发</td>
<td style="text-align:center">标记-清除</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td style="text-align:center">G1</td>
<td style="text-align:center">并发</td>
<td style="text-align:center">标记-整理+复制</td>
<td style="text-align:center">响应速度优先</td>
<td style="text-align:center">面向服务端应用，将来替换CMS</td>
</tr>
</tbody>
</table>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个结点。其中验证、准备和解析三个部分统称为连接。</p>
<p><img src="https://s2.loli.net/2023/07/19/ALrz9SgRtDF5NEh.jpg" alt="类加载过程"></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，虚拟机需要完成三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。大致上会完成四个阶段的校验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。首先这时候进行内存分配的仅包括类变量而不包括实例变量，其次这里所说的初始值通常情况下是数据类型的零值，假设一个类变量定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int v = 321;</span><br></pre></td></tr></table></figure>
<p>那么变量v在准备阶段过后的初始值是0而不是321。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是类加载过程的最后一步，到初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。</p>
<h4 id="类加载器与类的唯一性"><a href="#类加载器与类的唯一性" class="headerlink" title="类加载器与类的唯一性"></a>类加载器与类的唯一性</h4><p>类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。通俗的说，JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。</p>
<p>这里的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>站在Java虚拟机的角度讲，只存在两种不同的类加载器：启动类加载器（Bootstrap ClassLoader）和所有其他的类加载器。启动类加载器使用C++实现，是虚拟机自身一部分，而其他的类加载器都由Java实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。<br>站在Java开发人员的角度来看，类加载器可以分为以下三种系统提供的类加载器：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong> 这个类加载器负责将存放在&lt;JAVA_HOME&gt;lib目录中的，或者被-Xbootclasspath参数所制定的路径中的，并且是被虚拟机识别的类库加载到虚拟机内存中。该加载器无法被Java程序直接引用</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong> 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong> 这个类加载器由sun.misc.Launcher@AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
<p><img src="https://s2.loli.net/2023/07/19/xfpEW9gmt2eSNMb.png" alt="双亲委派模型"></p>
<p>上图所展示的类加载器之间的层次关系就称为双亲委派模型。它要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。使用组合（Composition）关系来复用父加载器。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Security CSRF防御</title>
    <url>/2019/09/08/Spring-Security%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在公司开发一个用Spring Boot框架的项目，用POST上传文件的时候死活上传不了，一直都是返回403，忙活了一个上午才发现是因为Spring Sercurity开启了CSRF防御，所以在POST请求中必须还要包含增加一个字段及数据才能请求成功，不然的话都会被Spring Sercurity给拦截掉并且认为是非法请求，比如我要提交表单数据，必须要增加一个隐藏的字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;$&#123;_csrf.parameterName&#125;&quot; value=&quot;$&#123;_csrf.token&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>详情可以在官方文档中看到，<a href="https://docs.spring.io/autorepo/docs/spring-security/3.2.0.CI-SNAPSHOT/reference/html/csrf.html" target="_blank" rel="noopener">https://docs.spring.io/autorepo/docs/spring-security/3.2.0.CI-SNAPSHOT/reference/html/csrf.html</a></p>
<h3 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3><p>看了一下官方文档才了解到这CSRF到底是什么，就像文档所说的，假如银行网站向用户提供转账功能，转账请求的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /transfer HTTP/1.1</span><br><span class="line">Host: bank.example.com</span><br><span class="line">Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">amount=100.00&amp;routingNumber=1234&amp;account=9876</span><br></pre></td></tr></table></figure>
<p>但是假如你登录到了银行网站，然后在还没注销的情况下又访问了一个恶意网站，这时你看到恶意网站上有个【领取奖品】按钮，你美滋滋地点击了这个按钮，却不知道这个按钮会提交这样的表单信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;https://bank.example.com/transfer&quot; method=&quot;post&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot;</span><br><span class="line">      name=&quot;amount&quot;</span><br><span class="line">      value=&quot;100.00&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot;</span><br><span class="line">      name=&quot;routingNumber&quot;</span><br><span class="line">      value=&quot;evilsRoutingNumber&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot;</span><br><span class="line">      name=&quot;account&quot;</span><br><span class="line">      value=&quot;evilsAccountNumber&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot;</span><br><span class="line">      value=&quot;Win Money!&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>最后你会收到一条信息，您向银行卡号XXX转账100元……当场流下悔恨的泪水，大喊三声“为什么”？！<br>因为恶意网站虽然没办法获取你的cookie信息，但是它向银行后端请求的时候，浏览器还是会将cookie信息一起发送的，银行当然不知道这个请求是恶意网站向它发送的，它只知道cookie是你的！</p>
<p><strong>像这种伪装成当前已登录认证用户去请求正在访问的网站后端的攻击方式，就被称为CSRF。</strong></p>
<p>所以解决办法就是增加一些表单信息，而这些信息是恶意网站所无法获取的！例如图片验证码什么的。但是除了登录注册的时候使用验证码外，其它时候也使用验证码的话，用户岂不是会觉得很烦，所以Spring Sercurity通过在WEB应用中增加前端过滤器，验证请求是否包含CSRF的token信息，不包含的自然就是非法请求咯，因为攻击网站是无法获取到token信息的，只要是跨域提交的信息，都是无法通过这个过滤器的校验的。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>下面是CsrfFilter中的doFilterInternal源码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response, FilterChain filterChain)</span><br><span class="line">					throws ServletException, IOException &#123;</span><br><span class="line">		request.setAttribute(HttpServletResponse.class.getName(), response);</span><br><span class="line">		// 先从tokenRepository中加载token</span><br><span class="line">		CsrfToken csrfToken = this.tokenRepository.loadToken(request);</span><br><span class="line">		final boolean missingToken = csrfToken == null;</span><br><span class="line">		  // 如果为空，则tokenRepository生成新的token，并保存到tokenRepository中</span><br><span class="line">		if (missingToken) &#123;</span><br><span class="line">			csrfToken = this.tokenRepository.generateToken(request);</span><br><span class="line">			this.tokenRepository.saveToken(csrfToken, request, response);</span><br><span class="line">		&#125;</span><br><span class="line">        // 将token写入request的attribute中，方便页面上使用</span><br><span class="line">		request.setAttribute(CsrfToken.class.getName(), csrfToken);</span><br><span class="line">		request.setAttribute(csrfToken.getParameterName(), csrfToken);</span><br><span class="line">		//这个macher就是我们在Spring配置文件中自定义的过滤器，也就是GET，HEAD, TRACE, OPTIONS和我们的rest都不处理</span><br><span class="line"> </span><br><span class="line">        // 这个macher就是我们在Spring配置文件中自定义的过滤器，</span><br><span class="line">		//如果不需要csrf验证的请求，则直接下传请求（requireCsrfProtectionMatcher是默认的对象，对符合^(GET|HEAD|TRACE|OPTIONS)$的请求和我们自定义的请求不验证）</span><br><span class="line">		if (!this.requireCsrfProtectionMatcher.matches(request)) &#123;</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">        // 从用户请求中获取token信息</span><br><span class="line">		String actualToken = request.getHeader(csrfToken.getHeaderName());</span><br><span class="line">		if (actualToken == null) &#123;</span><br><span class="line">			actualToken = request.getParameter(csrfToken.getParameterName());</span><br><span class="line">		&#125;</span><br><span class="line">        // 验证，如果相同，则下传请求，如果不同，则抛出异常</span><br><span class="line">		if (!csrfToken.getToken().equals(actualToken)) &#123;</span><br><span class="line">			if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">				this.logger.debug(&quot;Invalid CSRF token found for &quot;</span><br><span class="line">						+ UrlUtils.buildFullRequestUrl(request));</span><br><span class="line">			&#125;</span><br><span class="line">			if (missingToken) &#123;</span><br><span class="line">				this.accessDeniedHandler.handle(request, response,</span><br><span class="line">						new MissingCsrfTokenException(actualToken));</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				this.accessDeniedHandler.handle(request, response,</span><br><span class="line">						new InvalidCsrfTokenException(csrfToken, actualToken));</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		filterChain.doFilter(request, response);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>唉，有空还是得多到Spring官网看看文档了解了解框架啊，不然一个简单的问题就得搞半天！</p>
]]></content>
      <categories>
        <category>工作中遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 学习—第一个MVC：Hello World</title>
    <url>/2019/04/20/Spring-%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E6%AD%A5-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84MVC/</url>
    <content><![CDATA[<h1 id="Spring-学习—第一个MVC：Hello-World"><a href="#Spring-学习—第一个MVC：Hello-World" class="headerlink" title="Spring 学习—第一个MVC：Hello World"></a>Spring 学习—第一个MVC：Hello World</h1><p>Spring框架是Java应用最广的框架，它是开源的，是为了解决企业应用程序开发复杂性而创建的，想要做Java Web开发，怎么能不会Spring呢？想要学Spring，那第一步先学习怎么用Spring框架创建一个最简单的MVC吧！笔者用的是IDEA，所以这里就用IDEA来创建。</p>
<h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><p>首先当然是在IDEA新建项目。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbc9d90cc126.png" alt="IDEA新建项目"><br>类库选择”Spring MVC”，并且在JAVA EE中选择”Web Application”。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbc9f6326dd4.png" alt="选择类库"><br>输入项目名称以及选择项目的地址，然后点击finish。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca08ee6363.png" alt="输入项目名"><br>点击finish后，IDEA会自动下载需要的类库，大概等几分钟。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca08ec5768.png" alt="下载类库"><br>下载类库完毕后，项目就建立完成了！</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca1a33bcbd.png" alt="项目文件"></p>
<hr>
<h2 id="2-调试设置"><a href="#2-调试设置" class="headerlink" title="2.调试设置"></a>2.调试设置</h2><p>项目建立好后，可以看到右上角的run和debug按钮都是灰色的，不能运行调试，所以接下来我们要在IDEA进行运行、调试的相关设置。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca7fa00965.png" alt="灰色的运行和调试按钮"><br>在菜单栏中找到 Run-&gt;Edit Configurations，可以打开运行设置框。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca82fb4317.png" alt="运行调试配置"><br>按照下图添加本地Tomcat服务器配置。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca857a68f6.png" alt="添加服务器"><br>Name就是该配置的名称，随便取；After launch是设置你运行项目所自动打开的浏览器以及打开的URL，我喜欢用谷歌；HTTP port就是该项目的运行端口。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca873eec91.png" alt="输入相关配置"><br>然后再点击Deployment-&gt; + -&gt;Artifacy，设置好部署的url，直接填个”/“就行了，当然你也可以加点东西，比如填”/handsomedong”然后点击 OK 。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca89037029.png" alt="添加Artifacy"></p>
<p><img src="https://i.loli.net/2019/04/22/5cbca8abc0f47.png" alt="应用目录"><br>设置好运行调试的配置后，我们就可以在右上角看到配置名称了，同时也可以看到有个三角符号和虫子都变绿了。三角符号是运行按钮，点击后直接运行，小虫子是调试按钮，可以设置断点调试。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca9046f750.png" alt="变绿了"><br>我们先试试运行一下会怎么样吧！结果不出意料，根本没跑起来……我们在IDEA下面查看日志，可以看到报错信息</p>
<p><font color="#FF0000"><center><em>java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener</em> </center> </font><br>意思是找不到这个类！为什么呢？因为还有一些包没有jar包含进来。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbca9202eeaa.png" alt="日志报错信息"></p>
<hr>
<h2 id="3-导入相关类库"><a href="#3-导入相关类库" class="headerlink" title="3.导入相关类库"></a>3.导入相关类库</h2><p>点击左上角 File-&gt;Project Structure。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcac519ce36.png" alt="Project Structure"><br>点击Artifacts再点击项目后，可以看到错误的提醒，缺少了一些引用。我们可以通过点击”Fix”来查看IDEA有什么解决办法。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcac51ab62d.png" alt="Artifacts"><br>可以看到IDEA能为我们加入这些类库，那我们就点击最上面两个吧(请忽略我的QQ拼音输入法头像)！</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcad4fbae7d.png" alt="添加 Spring MVC-1.3.18 RELEASE"><br>添加完这些类库后，就可以看到已经没有错误的提醒了，我们再重新运行项目看看如何吧！</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcac5171a78.png" alt="重新运行"><br>这次终于运行成功了！！！运行成功后，IDEA会自动使用我们配置的浏览器，打开我们配置的URL！看看此时的运行结果，其实就是 web目录下的 index.jsp文件。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcac51642d0.png" alt="运行结果"></p>
<p><img src="https://i.loli.net/2019/04/22/5cbcac517e20f.png" alt="index.jsp文件"></p>
<hr>
<h2 id="4-添加控制器"><a href="#4-添加控制器" class="headerlink" title="4.添加控制器"></a>4.添加控制器</h2><p>既然项目能跑了，那我们就得正式开始写MVC了，我们先写一个Controller吧！<br>我们首先要添加一个新的包，报名自己取，我在src目录添加了一个名为”com.handsomedong.springmvc”的包。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcb22d90dd9.png" alt="添加新包"></p>
<p><img src="https://i.loli.net/2019/04/22/5cbcb22d7f475.png" alt="输入包名"><br>然后在这个包下添加一个Java Class，这个class就是控制器了，取名叫HelloController吧！</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcb22d8adf5.png" alt="添加Class"></p>
<p><img src="https://i.loli.net/2019/04/22/5cbcb22d67bfd.png" alt="输入类名"><br>HelloController代码如下。<br>在类上面添加注解 <em>@Controller</em> 注明该类是个控制器、<em>@RequestMapping(“/hello”)</em> 注明该控制器的路由为”/hello”，在方法test()上面添加注解 <em>@RequestMapping(“world”)</em> 注明该方法的路由为”world”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.handsomedong.springmvc;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;world&quot;)</span><br><span class="line">    public String test()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;/WEB-INF/jsp/world.jsp&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们想要访问该方法时，url应该为”/hello/world.form”，我知道你一定要问我为什么会有”.form”，那是因为默认配置就是这样！</p>
<p>我知道你肯定又会问我能不能在配置中把”.form”去掉，当然能！我们可以在 /web/WEB-INF/dispatcher-servlet.xml 中找到这么一段代码。把其中的 *.form 改成 / 就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h2 id="5-添加视图"><a href="#5-添加视图" class="headerlink" title="5.添加视图"></a>5.添加视图</h2><p>其实 HelloController 的 test() 意思是返回 /WEB-INF/jsp/world.jsp 这个View，所以我们要在 WEB-INF 下新建文件夹 jsp ，并且新建一个jsp文件。world.jsp 代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;HandsomeDong&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    Hello, world.</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>此时控制器和视图都建好了，我们运行一下项目，在浏览器输入 <a href="http://localhost:8080/hello/world" target="_blank" rel="noopener">http://localhost:8080/hello/world</a> 看看效果如何吧！</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcb9a734bef.png" alt="被404支配的恐惧"><br>怎么样，是不是要枯了……怎么又是404！！！年轻人别太心急，想想程序跑不起来我们第一步该干什么。</p>
<p><img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/p/www_apkbus_com/d4e669d65a97f2ee45af6bc42ba016ff.gif" alt="bug？一定是电脑的问题"><br>年轻人还是要戒骄戒躁啊，我们先来看看服务器这边报错好吧。</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcb9a73e678.png" alt="报错信息"><br>这里说 DispatcherServlet 没有找到响应 /hello/world 的控制器！为什么呢？我们路由配好了，输入的URL也没有错啊！<br>原因是我们还要告诉Spring去哪里找这些控制器……</p>
<p>我们找到 /web/WEB-INF/dispatcher-servlet.xml 这个文件，在 beans 里面添加这么一行代码，意思就是你记得要去我这个包里扫描控制器！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.handsomedong.springmvc&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>此时我们再重新运行一下试试看吧！终于成功了！！！</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcbb344abac.png" alt="Hello, world."></p>
<hr>
<h2 id="6-添加模型"><a href="#6-添加模型" class="headerlink" title="6.添加模型"></a>6.添加模型</h2><p>现在Controller和View都已经完成了，就剩一个Model了，我们写个最简单的吧，直接在Controller传入一个Model。回到HelloController，修改代码如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.handsomedong.springmvc;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;world&quot;)</span><br><span class="line">    public String test(Model model)</span><br><span class="line">    &#123;</span><br><span class="line">        model.addAttribute(&quot;name&quot;, &quot;HandsomeDong&quot;);</span><br><span class="line">        model.addAttribute(&quot;github&quot;, &quot;https://github.com/handsomedong&quot;);</span><br><span class="line">        return &quot;/WEB-INF/jsp/world.jsp&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再把Model的值放到页面中显示出来，现在把 world.jsp 代码修改如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;HandsomeDong&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello, $&#123;name&#125;.&lt;/p&gt;</span><br><span class="line">    &lt;a href=&quot;$&#123;github&#125;&quot;&gt; GitHub &lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在运行查看结果吧！</p>
<p><img src="https://i.loli.net/2019/04/22/5cbcbe1973bcb.png" alt="运行结果"><br>至此我们就完成了Spring框架最简单的MVC项目了！</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+Dubbo简单demo实践</title>
    <url>/2021/07/02/SpringBoot-Dubbo%E7%AE%80%E5%8D%95demo%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="SpringBoot-Dubbo-简单-demo-实践"><a href="#SpringBoot-Dubbo-简单-demo-实践" class="headerlink" title="SpringBoot + Dubbo 简单 demo 实践"></a>SpringBoot + Dubbo 简单 demo 实践</h1><p>休息了一个月终于又要上班了，下家公司的项目用的是Dubbo+Zookeeper，由于之前只用过Spring Cloud，所以提前了解一下Dubbo的使用，搭了个简单的 demo 感受 Dubbo 和 Spring Cloud 的区别。<br>大概流程如下：</p>
<ol>
<li>Zookeeper搭建</li>
<li>Dubbo可视化管理界面搭建</li>
<li>接口层定义</li>
<li>服务层实现</li>
<li>消费层调用</li>
</ol>
<h2 id="Dubbo基本工作原理"><a href="#Dubbo基本工作原理" class="headerlink" title="Dubbo基本工作原理"></a>Dubbo基本工作原理</h2><p>Dubbo 是一款 RPC 服务框架，它最大的优势在于提供了面向接口代理的服务编程模型，对开发者屏蔽了底层的远程通信细节。同时 Dubbo 也是一款服务治理框架，它为分布式部署的微服务提供了服务发现、流量调度等服务治理解决方案。</p>
<p>下图是 Dubbo 的基本工作原理图(在官网找的)，服务提供者与服务消费者之间通过注册中心协调地址，通过约定的协议实现数据交换。<br><img src="https://s2.loli.net/2023/07/19/RmB1wsW5jqTYAZv.png#pic_center" alt="Dubbo 基本工作原理图"><br>接下来就搭建一个 demo ，感受一下 Dubbo 的使用和 Spring Cloud 有什么区别。</p>
<h2 id="Zookeeper搭建"><a href="#Zookeeper搭建" class="headerlink" title="Zookeeper搭建"></a>Zookeeper搭建</h2><h3 id="Zookeeper下载"><a href="#Zookeeper下载" class="headerlink" title="Zookeeper下载"></a>Zookeeper下载</h3><p>Dubbo 使用 Zookeeper 作为注册中心，提供服务注册和发现，跟Spring Cloud的 eureka 或 nacos 类似。</p>
<p>所以第一步当然是去<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">官网</a>下载 Zookeeper 啦，我下载的版本是3.6.3。</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>下载解压后，进入 conf 文件夹可以看到有个 zoo_sample.cfg 文件，这个是配置文件示例，现在复制并更名为 zoo.cfg ，根据自己的需要对配置进行更改，我改了一下数据路径。<br>Zookeeper 的端口号默认是2181，可以根据自己的需要对 clientPort 的值进行更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir=E:/zookeeper/data</span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>进入bin文件夹可以看到里面有很多脚本，zkServer.cmd 和 zkServer.sh 就是启动脚本，我的电脑系统是 windows ，所以直接双击 zkServer.cmd 即可启动。</p>
<p><img src="https://s2.loli.net/2023/07/19/SnKa5EN2pIZO9RL.png#pic_center" alt="启动Zookeeper"></p>
<h2 id="Dubbo-可视化管理界面搭建"><a href="#Dubbo-可视化管理界面搭建" class="headerlink" title="Dubbo 可视化管理界面搭建"></a>Dubbo 可视化管理界面搭建</h2><p>Zookeeper 启动完成之后，我们需要一个可视化界面方便对服务进行观察和管理。</p>
<h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><p>Dubbo-admin的Github地址是 <a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin</a> ，直接 git clone 下来。项目里有 readme.md 介绍启动流程，参考 readme.md 启动项目。</p>
<h3 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h3><p>打开 dubbo-admin\dubbo-admin-server\src\main\resources\application.properties 可以修改配置，指定 Zookeeper 地址，我的 Zookeeper 是默认配置，所以不用修改。</p>
<h3 id="编译、打包项目"><a href="#编译、打包项目" class="headerlink" title="编译、打包项目"></a>编译、打包项目</h3><p>进入到项目里编译并打包项目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>
<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>可以直接在项目根目录运行 mvn –projects dubbo-admin-server spring-boot:run 启动项目，也可以进入 dubbo-admin-distribution\target 运行里面的jar包。</p>
<p><img src="https://s2.loli.net/2023/07/19/SVJFBcPLXlzGxmb.png#pic_center" alt="启动 dubbo-admin"></p>
<p><strong> 启动失败 </strong><br>我刚开始启动失败了，这个 dubbo-admin 的启动端口是 8080，但是我发现 8080 端口已经被占用了，最后发现是 Zookeeper 占用的，原来是 Zookeeper 内嵌了一个管理控制台，通过 jetty 启动，这个 jetty 的端口就是 8080，于是我去改了以下 Zookeeper 的 zoo.cfg ，新增了一行配置把 Zookeeper 的管理控制台端口改为 8081。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin.serverPort=8081</span><br></pre></td></tr></table></figure>
<h3 id="进入管理界面"><a href="#进入管理界面" class="headerlink" title="进入管理界面"></a>进入管理界面</h3><p>启动成功后就可以访问 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a> 了，默认的账号密码都是root。<br><img src="https://s2.loli.net/2023/07/19/fv5lIzuOY4d6RWZ.png#pic_center" alt="登录"></p>
<p><img src="https://s2.loli.net/2023/07/19/kWJmSxy5gLArGPE.png#pic_center" alt="Dubbo Admin"></p>
<h2 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h2><p>接下来就要创建工程了，先创建个 maven 多模块工程，里面需要包含三个模块，一个是 api 模块，一个是服务提供者模块，一个是服务消费者模块。</p>
<h3 id="api模块"><a href="#api模块" class="headerlink" title="api模块"></a>api模块</h3><p>假设我这个服务是一个用户查询的服务，那我就需要先创建一个 dto 和一个接口。<br><img src="https://s2.loli.net/2023/07/19/N2jn3OCBtpPaT4r.png" alt="api 模块"></p>
<h4 id="创建-UserInfo-类"><a href="#创建-UserInfo-类" class="headerlink" title="创建 UserInfo 类"></a>创建 UserInfo 类</h4><p>创建一个用户信息类，需要注意的是，dto 要实现 Serializable 接口进行序列化。当然，也可以使用其它的序列化方式，hessian2、json等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserInfo implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2908612893636115165L;</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    private Long userId;</span><br><span class="line"></span><br><span class="line">    public static long getSerialVersionUID() &#123;</span><br><span class="line">        return serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getUserId() &#123;</span><br><span class="line">        return userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserId(Long userId) &#123;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义用户服务接口"><a href="#定义用户服务接口" class="headerlink" title="定义用户服务接口"></a>定义用户服务接口</h4><p>简单定义一个接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public List&lt;UserInfo&gt; getUserInfoList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务提供者模块"><a href="#服务提供者模块" class="headerlink" title="服务提供者模块"></a>服务提供者模块</h3><p>现在创建一个服务提供者模块。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>这个模块需要 Dubbo 和 Zookeeper 相关依赖，再加上这个模块是要实现 UserService 接口，所以也需要刚才创建的 api 模块依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;dubbo.version&gt;2.7.5&lt;/dubbo.version&gt;</span><br><span class="line">    &lt;curator.version&gt;2.12.0&lt;/curator.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Zookeeper dependencies --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.handsomedong&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>配置文件主要需要以下配置：<br><img src="https://s2.loli.net/2023/07/19/d3WH21YxENk7fZ6.png" alt="配置文件"></p>
<p>根据上图的配置，修改 application.yml，我的配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line"></span><br><span class="line">debug: true</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: user-service-provider</span><br><span class="line">  registry:</span><br><span class="line">    address: 127.0.0.1:2181</span><br><span class="line">    protocol: zookeeper</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 19000</span><br><span class="line">  monitor:</span><br><span class="line">    protocol: registry</span><br></pre></td></tr></table></figure></p>
<h4 id="用户服务类具体实现"><a href="#用户服务类具体实现" class="headerlink" title="用户服务类具体实现"></a>用户服务类具体实现</h4><p>实现用户服务接口，注意这里的 @Service 注解，不是 Spring 的注解，而是 Dubbo 的注解！包的全路径是 org.apache.dubbo.config.annotation.Service。<br>并且需要注意的是，它必须要实现 UserService 接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Component</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;UserInfo&gt; getUserInfoList() &#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            UserInfo userInfo = new UserInfo();</span><br><span class="line">            userInfo.setUserId(Integer.valueOf(i).longValue());</span><br><span class="line">            userInfo.setUserName(&quot;七里翔&quot; + i);</span><br><span class="line">            userInfoList.add(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return userInfoList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringBoot-启动类"><a href="#SpringBoot-启动类" class="headerlink" title="SpringBoot 启动类"></a>SpringBoot 启动类</h4><p>最后在启动类要加上 @EnableDubbo 注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDubbo</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class UserProviderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查看-Dubbo-Admin"><a href="#查看-Dubbo-Admin" class="headerlink" title="查看 Dubbo Admin"></a>查看 Dubbo Admin</h4><p>现在再去 Dubbo Admin 上面就可以看到这个服务注册成功了！点击详情也可以看到服务的具体信息。<br><img src="https://s2.loli.net/2023/07/19/aF1lCeZkbI8HYtA.png" alt="Dubbo Admin"></p>
<p><img src="https://s2.loli.net/2023/07/19/x9IWKMvbJnLVBl4.png" alt="服务详情"></p>
<h3 id="服务消费者模块"><a href="#服务消费者模块" class="headerlink" title="服务消费者模块"></a>服务消费者模块</h3><p>最后就是创建服务消费者模块了，在该模块下进行服务调用。</p>
<h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><p>依赖基本和服务提供者相同，这个就不多BB了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;dubbo.version&gt;2.7.5&lt;/dubbo.version&gt;</span><br><span class="line">    &lt;curator.version&gt;2.12.0&lt;/curator.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Zookeeper dependencies --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.handsomedong&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10000</span><br><span class="line">debug: true</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: user-service-consumer</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:2181</span><br><span class="line">  monitor:</span><br><span class="line">    protocol: registr</span><br></pre></td></tr></table></figure>
<h4 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h4><p>我这里直接创建个 Controller 来测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;test&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @Reference	//dubbo</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;test&quot;)</span><br><span class="line">    public List&lt;UserInfo&gt; test() &#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = userService.getUserInfoList();</span><br><span class="line">        return userInfoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringBoot-启动类-1"><a href="#SpringBoot-启动类-1" class="headerlink" title="SpringBoot 启动类"></a>SpringBoot 启动类</h4><p>这个启动类同样要加上 @EnableDubbo 注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDubbo</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class UserConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动服务消费者后，断点调试、用 postman 测试一下。</p>
<p><img src="https://s2.loli.net/2023/07/19/UGLvxHwCRNcMsqI.png" alt="断点调试"></p>
<p><img src="https://s2.loli.net/2023/07/19/rXKsIJBAYU1Hlpk.png" alt="postman"></p>
<p>可以看到已经大功告成了！！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Dubbo-和-Spring-Cloud-区别"><a href="#Dubbo-和-Spring-Cloud-区别" class="headerlink" title="Dubbo 和 Spring Cloud 区别"></a>Dubbo 和 Spring Cloud 区别</h3><ol>
<li>Dubbo 耦合较高，有一定约束。这是我使用中感受到的最大的区别，Dubbo 需要我们定义个抽象接口，然后提供方实现这个接口，消费方再通过这个接口进行调用。提供方和消费方都依赖于这个接口的模块，所以整个项目是有一定的耦合的。而Spring Cloud 我们使用 Feign 就比较自由，比较轻量化，通过 REST 调用，更灵活。这不能单纯地说是优点或者是缺点吧，毕竟接口定义过轻也很容易多版本的情况下导致接口文档与实际所展现功能不一致导致服务集成时的问题，或许对版本控制比较严格有时候反而会更加稳定。</li>
<li>Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输的；而 Spring Cloud 是基于 Http 协议+ REST 接口调用远程过程的通信。在传输协议和序列化方式上，Dubbo 的性能要比 Spring Cloud 更高。因为 Dubbo 是长连接并且用二进制传输，占用带宽更少。而 Spring Cloud 使用的是短连接并且使用 JSON 序列化，消耗更大。</li>
<li>Dubbo 只是一个 RPC 框架，而 Spring Cloud 是一整套微服务的解决方案，因此它们的领域是不一样的。</li>
<li>社区方面，Spring Cloud 要比 Dubbo 活跃很多很多很多很多……Dubbo 好久没更新了，而 Spring Cloud 目前还一直在更新，很活跃！</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/19/Qt4rfk8dsqL1Ugb.png" alt="Dubbo 流泪"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Triton入门初体验</title>
    <url>/2024/04/26/Triton%E5%85%A5%E9%97%A8%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近玩AIGC玩得不亦乐乎（<a href="https://www.douyin.com/user/MS4wLjABAAAAbp_jw1fRXJUZ5KdXt7cYjGg84WcTVL-FHFL_Fz9_d3w" target="_blank" rel="noopener">我的视频账号</a>），对相关的技术也产生了浓厚的兴趣，所以也了解了一些机器学习相关的知识，也自己动手折腾了一下。<del>正好也挺久没水博客了呢，今天正好有时间，顺便水一篇吧。</del></p>
</blockquote>
<p>最近这两年随着ChatCPT、Stable Diffusion等生成式AI极速发展，各种AI模型也如雨后春笋般涌现，现在各大厂都在训练大模型，以及开发AIGC平台。</p>
<p>NVIDIA Triton Inference Server是一个针对CPU和GPU进行优化的云端推理的解决方案，支持绝大部分主流的模型框架，包括TensorFlow、TensorRT、PyTorch、ONNX Runtime等，为我们在生产环境中部署及使用AI模型提供了极大的便利，估计现在很多大厂开发的AIGC平台都用到Triton或者其它类似的服务化框架（比如TensorFlow Serving、Torch Serve、Kubeflow等），所以学习了Triton的一些基础架构和设计原理后，动手部署并且用了一下，<del>顺便水一篇文章</del>。</p>
<p><img src="https://s2.loli.net/2024/04/26/x7GyPLwXmbJDdaE.png" alt="别打了"></p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="Docker-WSL2安装"><a href="#Docker-WSL2安装" class="headerlink" title="Docker WSL2安装"></a>Docker WSL2安装</h2><p>从0编译Triton服务端应该会非常麻烦，一定会被不计其数的依赖报错困扰半天，所以我直接用Docker来部署。<br>由于我用的是Windows，所以需要在安装<a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noopener">Docker Desktop</a>来使得WSL2可以使用Docker CLI以及Docker Daemon等核心组件，具体安装以及设置过程这里就不多做赘述，直接到Docker官网及Windows官网查阅相关资料step by step即可。</p>
<h2 id="注册-amp-登录NGC平台账号"><a href="#注册-amp-登录NGC平台账号" class="headerlink" title="注册&amp;登录NGC平台账号"></a>注册&amp;登录NGC平台账号</h2><p>NGC简单来说就是NVIDIA的一个官方软件仓库，仓库里有很多编译好的软件、Docker镜像等，你需要注册NGC并生成api key，用这个api key来登录NGC并下载里面的镜像。具体可参考<a href="https://docs.nvidia.com/ngc/gpu-cloud/ngc-catalog-user-guide/index.html#registering-activating-ngc-account" target="_blank" rel="noopener">官方教程</a>，比较简单，这里也不过多赘述。</p>
<p>完成注册后直接使用指令登录即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login nvcr.io</span><br></pre></td></tr></table></figure>
<p>之后会需要输入用户名以及api key，出现 Login Successed 即登录成功。</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>接下来就要拉取镜像了</p>
<p><img src="https://s2.loli.net/2024/04/27/PGw7hT6nNayI4VE.png" alt="搜索截图"></p>
<p>从官方文档可以看到，xx.yy-py3 就是能支持Tensorflow、PyTorch等主流模型框架的Triton服务端镜像，而下面还有个 xx.yy-py3-sdk 镜像包含了客户端相关库、例子可以让我们请求服务端，以方便测试。这两个镜像都下载下来，前者是服务端镜像，后者是客户端测试镜像。</p>
<p><img src="https://s2.loli.net/2024/04/27/U5HCdXRDIoLfQsS.png" alt="镜像说明"></p>
<p>点进来可以找到镜像路径，直接copy即可，然后拉取镜像</p>
<p><img src="https://s2.loli.net/2024/04/27/nvHTSPjoK6pGZRw.png" alt="镜像路径"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nvcr.io/nvidia/tritonserver:24.03-py3</span><br><span class="line">docker pull nvcr.io/nvidia/tritonserver:24.03-py3-sdk</span><br></pre></td></tr></table></figure>
<h2 id="准备测试模型和数据"><a href="#准备测试模型和数据" class="headerlink" title="准备测试模型和数据"></a>准备测试模型和数据</h2><p>接下来需要先准备测试模型和数据，<a href="https://github.com/triton-inference-server/server" target="_blank" rel="noopener">Triton Server</a>仓库准备了很多onnx模型和测试图片，直接拿来用就行了。</p>
<p>先下载仓库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b r22.12 https://github.com/triton-inference-server/server.git</span><br></pre></td></tr></table></figure></p>
<p>执行fetch_models.sh，下载ONNX测试模型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd server/docs/examples</span><br><span class="line">./fetch_models.sh</span><br></pre></td></tr></table></figure></p>
<h2 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h2><p>一切准备就绪，接下来启动容器吧！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --gpus=1 --rm --net=host -v $&#123;PWD&#125;/model_repository:/models nvcr.io/nvidia/tritonserver:24.03-py3 tritonserver --model-repository=/models</span><br></pre></td></tr></table></figure></p>
<p>挑几个重要参数说说</p>
<ul>
<li>-gpus=1：代表是否启动GPU容器，如果该值为0，则Triton将运行在CPU Only模式，此时Triton的吞吐量和单个request的执行延迟会大幅增加，建议在条件允许的情况下默认打开。</li>
<li>-v：代表目录挂载。这里我们将examples下的model_repository目录挂载到了/models下</li>
<li>tritonserver：即代表我们要执行的二进制程序是tritonserver</li>
<li>–model-repository=/models：用于指定模型的仓库位置，由于我们之前将我们宿主机的模型挂载到容器的/models目录下，所以这里写/models就好了</li>
</ul>
<h2 id="验证服务可用性"><a href="#验证服务可用性" class="headerlink" title="验证服务可用性"></a>验证服务可用性</h2><p>发个HTTP请求获取服务器的状态（这里说明一下，启动容器后默认会占用3个端口，8000为http服务端口，8001为GRPC服务端端口，8002为metrics端口，启动服务时可以看到相关信息）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v localhost:8000/v2/health/ready</span><br></pre></td></tr></table></figure></p>
<p>得到响应<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Trying 127.0.0.1:8000...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to localhost (127.0.0.1) port 8000 (#0)</span><br><span class="line">&gt; GET /v2/health/ready HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8000</span><br><span class="line">&gt; User-Agent: curl/7.68.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Mark bundle as not supporting multiuse</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Content-Length: 0</span><br><span class="line">&lt; Content-Type: text/plain</span><br><span class="line">&lt;</span><br><span class="line">* Connection #0 to host localhost left intact</span><br></pre></td></tr></table></figure></p>
<p>可以看出来服务是正常的</p>
<h2 id="验证推理服务"><a href="#验证推理服务" class="headerlink" title="验证推理服务"></a>验证推理服务</h2><p>既然服务状态正常，那接下来看看推理是否正常，之前拉取的第二个镜像现在就派上了用场<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --net=host nvcr.io/nvidia/tritonserver:24.03-py3-sdk</span><br><span class="line">/workspace/install/bin/image_client -m densenet_onnx -c 3 -s INCEPTION /workspace/images/mug.jpg</span><br></pre></td></tr></table></figure></p>
<p>得到响应<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image &apos;/workspace/images/mug.jpg&apos;:</span><br><span class="line">    15.349571 (504) = COFFEE MUG</span><br><span class="line">    13.227469 (968) = CUP</span><br><span class="line">    10.424896 (505) = COFFEEPOT</span><br></pre></td></tr></table></figure></p>
<p>可以看到Triton Server的推理结果是<b>咖啡杯</b>，我看了看图片确实如此，所以模型没有异常，完美！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Triton Inference Server通过将模型统一放置在模型仓库中进行统一管理，使用gRPC/HTTP2接受及响应推理请求，使得Triton在保证高性能的同时，也有着极强的可用性和扩展性，怪不得大家都在用呢！我这次简单的使用只能说是大概了解了Triton的基本使用方法，它的很多特性我都还没使用到，恐怕入门都还没达到，有空再继续探索一下！</p>
<p><img src="https://s2.loli.net/2024/04/27/yxsbT4tnXI39uaq.png" alt="完美"></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Triton</category>
      </categories>
      <tags>
        <tag>AIGC</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs 第一关</title>
    <url>/2025/08/09/sqli-labs-%E7%AC%AC%E4%B8%80%E5%85%B3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近也是玩上了CTF啊，不过CTF涉及到的知识点可真多，先从最简单的web安全-SQL注入学起吧！听说 SQLi Labs 是一个开源且全面的 SQL 注入靶场，那就拿这个来练练 SQL 手工注入吧！同时也学学 sqlmap 的使用。</p>
</blockquote>
<h1 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h1><h2 id="判断是否存在-SQL-注入"><a href="#判断是否存在-SQL-注入" class="headerlink" title="判断是否存在 SQL 注入"></a>判断是否存在 SQL 注入</h2><ol>
<li>一进来就提醒输入一个数字的id值</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/zmUvZL6F91Gatuh.png" alt="image.png"></p>
<ol start="2">
<li>输入发现会回显内容，输入不同的id值，会回显不同的内容，所以我们后端应该就是根据我们输入的值来查询数据了。（这里推荐使用 chrome 的 HackBar 插件，在浏览器直接输入的话，特殊符号老是被编码，不太好看）</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/G1D9AYaqi7KMbEC.png" alt="image.png"></p>
<ol start="3">
<li>接下来判断是否存在注入，是字符型注入还是数字型注入<br>直接输入 1 是没问题的，但是输入 1’ 就报错了，所以这应该是字符型注入。</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/hVKdEtHfIvbL9C5.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2025/08/09/Nj87fe3Z5uaOt2l.png" alt="image.png"></p>
<ol start="4">
<li>进一步验证猜想<br>为了进一步验证这是字符型，可以使用 AND 1=1、 AND 1=2 查看结果。</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/426VUfPjYKmu5DW.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2025/08/09/YR9xturkiwEf5FA.png" alt="image.png"><br>从上面2张图可以确定这不是数字型注入了，因为 AND 后面的条件没生效。</p>
<p><img src="https://s2.loli.net/2025/08/09/oPbjvZQrVqL924u.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2025/08/09/2CaEwxKeHSVtd3s.png" alt="image.png"><br>从上面2张图可以确定这是字符型注入，使用单引号闭合了前面的查询条件，因此 AND 后面的查询条件生效了，所以2次查询结果不一样。</p>
<h2 id="联合注入爆数据"><a href="#联合注入爆数据" class="headerlink" title="联合注入爆数据"></a>联合注入爆数据</h2><ol>
<li>确定 SELECT 列数<br>接下来就是使用联合注入爆各种数据了，不过在此之前需要先确定一下 SELECT 的内容有多少列，因为 UNION 的列数需要一致。<br>使用 ORDER BY 来确认列数，ORDER BY 4 时报错了，所以 SELECT 的列数是3。</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/lMm5iyFq1bCQzJH.png" alt="image.png"></p>
<ol start="2">
<li>爆显示位<br>输入一个不存在的id，把后面的内容 UNION 上去，确认显示位。<br>可以看到回显的内容是第二、第三列。</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/aqgoCQbSxNH2RGj.png" alt="image.png"></p>
<ol start="3">
<li>爆库名<br>接下来就可以爆整个数据库实例的库名了，先使用 database() 查看当前查询的库，以及查询 information_schema.schemata 的 schema_name 列获取所有库名。</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/76edbohSy5rZKU2.png" alt="image.png"></p>
<ol start="4">
<li>爆表名<br>查询 information_schema.tables 获取 security 库下的所有表名。</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/6lsrvCjtez3Rxnc.png" alt="image.png"></p>
<ol start="5">
<li>爆字段<br>当前显示了用户名、密码，这些数据肯定存在 users 表中，所以查查这张表有什么字段吧！<br>可以看到表中的字段有 id、username、password</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/zFs6qEQfJaTjCYx.png" alt="image.png"></p>
<ol start="6">
<li>爆数据<br>直接查询 users 表的 username 和 password</li>
</ol>
<p><img src="https://s2.loli.net/2025/08/09/m6VIKUxEyejuX8t.png" alt="image.png"></p>
<h1 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h1><h2 id="使用-sqlmap-注入"><a href="#使用-sqlmap-注入" class="headerlink" title="使用 sqlmap 注入"></a>使用 sqlmap 注入</h2><p>sqlmap github: <a href="https://github.com/sqlmapproject/sqlmap" target="_blank" rel="noopener">https://github.com/sqlmapproject/sqlmap</a></p>
<ol>
<li>先查询所有库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://192.168.0.120:10000/Less-7/?id=1 --dbs</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/09/1T8fLmZjkMVv2W3.png" alt="image.png"></p>
<ol start="2">
<li>查询 security 下的表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://192.168.0.120:10000/Less-7/?id=1 -D security</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/09/MsNDXunrwGg6tlo.png" alt="image.png"></p>
<ol start="3">
<li>查询 users 表数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://192.168.0.120:10000/Less-7/?id=1 -D security -T users --columns --dump</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/09/5KaN9YlTciSrXWL.png" alt="image.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>先确认是字符型注入还是数字型注入，再使用注释把后面的 SQL 注释掉，然后确认注入格式，再使用联合注入查询库、表名，最后查询数据</li>
<li>这种简单的 case，sqlmap 直接能解决。不过现在处于练习阶段，还是得手工注入，理解原理</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
        <category>Writeup</category>
        <category>sqli-labs</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web安全</tag>
        <tag>Writeup</tag>
        <tag>sqli-labs</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Write-up-CTFHUB-web之SVN泄露</title>
    <url>/2025/08/19/Write-up-CTFHUB-web%E4%B9%8BSVN%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SVN 是一款类似于 git 的版本控制工具，不过比 git 要简单易用，但是使用人数应该是比 git 少得多的，这工具我也很少用，以前在第一家公司时倒是用过，但是我用得比较少，主要是游戏研发部门的项目用到。</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h2><p>项目地址：<a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></p>
<p>dirsearch 是一款基于 python3 的扫描工具，常用于暴力扫描页面结构，包括网页中的目录和文件</p>
<h2 id="dvcs-ripper"><a href="#dvcs-ripper" class="headerlink" title="dvcs-ripper"></a>dvcs-ripper</h2><p>dvcs-ripper 是一款基于 perl 的版本控制软件信息泄露利用工具，支持 SVN, GIT, Mercurial/hg, bzr 等</p>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>打开页面是这样的，提示我们 flag 在源代码里<br><img src="https://s2.loli.net/2025/08/20/FqeovAQhsWcg8Pl.png" alt="0.png"></p>
<p>使用 dirsearch 工具扫描这个页面，得到扫描结果后，搜索 200 看看请求成功的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://challenge-776f8dc47b983ee8.sandbox.ctfhub.com:10800/</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/20/M27dWBkuiG1RNTa.png" alt="2.png"></p>
<p>从上面的图中可以看到是 .svn 文件夹泄露了，因此使用 dvcs-ripper 工具还原文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl /home/kali/tools/dvcs-ripper/rip-svn.pl -u http://challenge-776f8dc47b983ee8.sandbox.ctfhub.com:10800/.svn</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/20/d1JPqvsYeXRNGhK.png" alt="3.png"></p>
<p>用 vscode 打开工程，搜索一下 flag 或者 ctfhub，可以找到 flag</p>
<p><img src="https://s2.loli.net/2025/08/20/E8Gm7Ze4bBYRyHg.png" alt="4.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>信息泄露题可以先使用 dirsearch 工具确认哪些信息可能泄露了，再对症下药，用相应的工具利用泄露的文件找到 flag 。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
        <category>Writeup</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web安全</tag>
        <tag>Writeup</tag>
        <tag>信息泄露</tag>
        <tag>SVN泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/06/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h1><p>有一些对象我们只需要一个，如果创建了多个实例，有可能会出现各种问题，比如线程池、注册表、缓存等等，这个时候就要用到单例模式了。一开始我以为单例模式会很容易，不就是把构造方法设为私有再提供一个静态方法去获取这个实例嘛，然而仔细了解后我才发现事情并没那么简单，它居然有好几种写法……</p>
<p><img src="https://i.loli.net/2019/06/20/5d0a5d8b0b09894035.png" alt="事情没那么简单"></p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>单例模式(Singleton Pattern)确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>
<p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>
<h2 id="2-实例说明"><a href="#2-实例说明" class="headerlink" title="2.实例说明"></a>2.实例说明</h2><h3 id="2-1-饿汉模式"><a href="#2-1-饿汉模式" class="headerlink" title="2.1 饿汉模式"></a>2.1 饿汉模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式在类加载的时候直接完成初始化，因此类加载会有点慢，但是获取对象的速度快，而且可以避免多线程的同步问题。</p>
<h3 id="2-2-懒汉模式（线程不安全）"><a href="#2-2-懒汉模式（线程不安全）" class="headerlink" title="2.2 懒汉模式（线程不安全）"></a>2.2 懒汉模式（线程不安全）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton()&#123;&#125;;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断有没有实例，没有的话再创建实例。这种没有考虑到线程安全，多线程的时候可能会同时构造多个对象。</p>
<p>你可能想到了，我们在getinstance()方法前加锁同步不就得了嘛……所以就有了下面这种写法。</p>
<h3 id="2-3懒汉模式（线程安全）"><a href="#2-3懒汉模式（线程安全）" class="headerlink" title="2.3懒汉模式（线程安全）"></a>2.3懒汉模式（线程安全）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton()&#123;&#125;;</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候每个线程进入到getinstance()方法之前都要等别的线程离开该方法，这得浪费多少资源啊……这种方式的效率是比较低的。</p>
<h3 id="2-4-双重检查模式"><a href="#2-4-双重检查模式" class="headerlink" title="2.4 双重检查模式"></a>2.4 双重检查模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式对进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。并且使用了volatile关键字，虽然牺牲了一点性能，但是提高了准确性。</p>
<h3 id="2-5-静态内部类"><a href="#2-5-静态内部类" class="headerlink" title="2.5 静态内部类"></a>2.5 静态内部类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123; </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">      public static Singleton getInstance()&#123;  </span><br><span class="line">        return SingletonHolder.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">        private static final Singleton instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载Singleton类时并不会初始化instance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化instance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，推荐使用静态内部类单例模式。</p>
<h3 id="2-6-其它"><a href="#2-6-其它" class="headerlink" title="2.6 其它"></a>2.6 其它</h3><p>除此之外还有<strong>枚举单例</strong>和<strong>容器实现单例</strong>，不过我不是很熟，这里就不写了……等什么时候熟一点了我再写写吧！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/2019/06/20/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>新建一个栈，利用栈的先进后出的特性，从头到尾遍历链表依次放到栈里，最后再从栈中一个个弹出来。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; value;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        while (p != NULL) &#123;</span><br><span class="line">            stk.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!stk.empty()) &#123;</span><br><span class="line">            value.push_back(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; tmp = new ArrayList();</span><br><span class="line">        while (listNode != null) &#123;</span><br><span class="line">            stk.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!stk.empty())&#123;</span><br><span class="line">            tmp.add(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
        <category>剑指offer算法题</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派使用samba在局域网共享文件</title>
    <url>/2019/12/15/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8samba%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>新买的树莓派4终于到了！！！我的树莓派3B+光荣退休！到手第一步当然是用树莓派通过SMB共享我硬盘里的文件啦，随传随看。</p>
<p><img src="https://s2.loli.net/2023/07/19/l72kpZNU8OXwPWy.jpg" alt="你懂的"></p>
<h3 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h3><p>samba是一个能让Linux系统应用Microsoft网络通讯协议的软件，而SMB是Server Message Block的缩写，即为服务器消息块 ，SMB主要是作为Microsoft的网络通讯协议，后来samba将SMB通信协议应用到了Linux系统上，就形成了现在的samba软件。后来微软又把 SMB 改名为 CIFS（Common Internet File System），即公共 Internet 文件系统，并且加入了许多新的功能，这样一来，使得samba具有了更强大的功能。</p>
<p>所以首先得安装samba。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install samba samba-common-bin</span><br></pre></td></tr></table></figure></p>
<h3 id="新建用户并与要共享的文件夹绑定"><a href="#新建用户并与要共享的文件夹绑定" class="headerlink" title="新建用户并与要共享的文件夹绑定"></a>新建用户并与要共享的文件夹绑定</h3><p>接下来先新建一个用户用于其它设备通过samba访问共享文件夹时登录访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd share	//新建用户</span><br><span class="line">passwd share    //设置用户密码</span><br><span class="line">mkdir /home/share    //新建一个文件夹</span><br><span class="line">chown -R share /home/share    //绑定</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/07/19/NtuRO2EzSZHdYyU.jpg" alt="新建用户"></p>
<h3 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h3><p>用户和文件夹都建好了，现在就要根据情况修改配置了。配置文件路径是 /etc/samba/smb.conf ，打开这个文件，在文件最后添加共享账户和共享文件夹的一些信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[HandsomeDong]	#网络中显示的文件名称</span><br><span class="line">    path = /home/share	#文件路径</span><br><span class="line">    valid users = share	#允许浏览的用户</span><br><span class="line">    browseable = yes	#允许浏览</span><br><span class="line">    public = yes		#允许共享访问</span><br><span class="line">    writable = yes		#允许写入</span><br></pre></td></tr></table></figure>
<h3 id="设置共享密码以及重启"><a href="#设置共享密码以及重启" class="headerlink" title="设置共享密码以及重启"></a>设置共享密码以及重启</h3><p>访问共享文件时，用的是samba设置的共享密码，而不是linux用户密码，现在要设置的就是共享密码，设置好后直接重启samba服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbpasswd -a share</span><br><span class="line">service smbd restart</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/07/19/ukJ68IjhBtnbegr.jpg" alt="设置密码、重启samba服务"></p>
<h3 id="访问共享文件夹"><a href="#访问共享文件夹" class="headerlink" title="访问共享文件夹"></a>访问共享文件夹</h3><h4 id="电脑访问"><a href="#电脑访问" class="headerlink" title="电脑访问"></a>电脑访问</h4><p>用windows系统访问共享文件夹，只需在资源管理器输入 \\IP 就可以直接看到共享文件夹了，输入用户名和共享密码就可以访问了。现在把我前几天买的1T硬盘挂载到这个文件夹下，我就可以肆意地往里面存片子了！！！</p>
<p><img src="https://s2.loli.net/2023/07/19/YdNgS6hDXkcOGp3.jpg" alt="文件夹"></p>
<p><img src="https://s2.loli.net/2023/07/19/I2ERBc931Ylautb.jpg" alt="输入用户名、密码"></p>
<p><img src="https://s2.loli.net/2023/07/19/UNiGLEF184wXqJW.jpg" alt="片子"></p>
<h4 id="安卓手机访问"><a href="#安卓手机访问" class="headerlink" title="安卓手机访问"></a>安卓手机访问</h4><p>安卓手机有不少APP都能使用SMB协议，我用的比较多的是 Solid Explorer 和 Kodi。Solid Explorer用来管理文件，视频、文本、音频、图片什么的浏览、管理起来都比较方便，Kodi浏览视频和图片非常好，非常强大！</p>
<h3 id="ipad、iphone访问"><a href="#ipad、iphone访问" class="headerlink" title="ipad、iphone访问"></a>ipad、iphone访问</h3><p>App Store上有很多软件都可以，收费的体验更好！</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>使用cryptsetup加密硬盘</title>
    <url>/2019/12/09/%E4%BD%BF%E7%94%A8cryptsetup%E5%8A%A0%E5%AF%86%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<p>在京东关注移动硬盘好久了，等了很久终于等到希捷移动硬盘几个月以来的最低价……299！咬咬牙终于下单，今天早上到手。</p>
<p><img src="https://s2.loli.net/2023/07/19/Eplcnd6wJ5kBa9P.jpg" alt="1T希捷移动硬盘"></p>
<p>这个移动硬盘主要用来给我的树莓派外接，然后用SMB共享，这样在内网条件下，我的手机、电脑、平板等就可以随时访问硬盘里的内容了，不过在此之前，我还得对硬盘进行加密，免得谁偷偷把我硬盘拿走了后随意浏览里面一些不可描述的东西。<br>cryptsetup是linux下的一个分区加密工具，它通过调用内核中的”dm-crypt”来实现磁盘加密的功能，这个加密工具应该还挺常用的，我的树莓派就是用的这个加密工具。不过在此之前，我们得先初始化这个硬盘</p>
<p><img src="https://s2.loli.net/2023/07/19/3WxiDyncuBOZk1q.jpg" alt="不可描述"></p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h4 id="找到设备"><a href="#找到设备" class="headerlink" title="找到设备"></a>找到设备</h4><p>第一步先对硬盘进行分区。把移动硬盘插到树莓派上，用 <strong>fdisk -l</strong> 看看是哪个硬盘。</p>
<p><img src="https://s2.loli.net/2023/07/19/eHoL7msGJdWiXI1.jpg" alt="fdisk -l"></p>
<p>很明显这个 /dev/sdb1 就是我插进去的移动硬盘。</p>
<h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h4><p>现在输入命令 <strong>fdisk /dev/sdb1</strong> 来操作这个硬盘。然后可以输入 m 来查看操作提示。</p>
<p><img src="https://s2.loli.net/2023/07/19/rsFEMj7XRoIdzmU.jpg" alt="操作提示"></p>
<p>可以看到 n 是添加新分区，那就输入 <strong>n</strong> 吧。</p>
<p><img src="https://s2.loli.net/2023/07/19/ovxlKT682Jm4D3Z.jpg" alt="添加新分区"></p>
<p>这个时候询问我们是要创建主分区还是扩展分区，主分区最多只能创建4个，如果创建了扩展分区那么扩展分区需要占用一个主分区，直接enter则默认是主分区，后面还有询问分区序号、分区大小什么的，我一路直接enter了，即默认。</p>
<p><img src="https://s2.loli.net/2023/07/19/YCFzdca9Q8Ju41U.jpg" alt="创建主分区"></p>
<p>创建好后可以输入 <strong>p</strong> 来查看逻辑分区。</p>
<p><img src="https://s2.loli.net/2023/07/19/TFcEHC8DkxQryK7.jpg" alt="查看逻辑分区"></p>
<p>可以看到我此时是只有一个分区的，大小是931.5G，现在可还没分区成功，还需要输入 <strong>w</strong> 保存。</p>
<h3 id="加密格式化"><a href="#加密格式化" class="headerlink" title="加密格式化"></a>加密格式化</h3><p>OK，现在硬盘基本的初始化完成了，现在要开始对它进行加密了。我这里用的是分区加密工具是cryptsetup，没有的话需要先安装。安装方法很简单，这里就不详细介绍了。<br>现在输入 <strong>cryptsetup luksFormat /dev/sdb1</strong> ，然后输入YES确认（注意要大写），再输入你要给硬盘设置的密码。<br><img src="https://s2.loli.net/2023/07/19/l7fdZCen8NJMRp2.jpg" alt="加密格式化"></p>
<h3 id="打开并挂载硬盘"><a href="#打开并挂载硬盘" class="headerlink" title="打开并挂载硬盘"></a>打开并挂载硬盘</h3><h4 id="打开加密的硬盘"><a href="#打开加密的硬盘" class="headerlink" title="打开加密的硬盘"></a>打开加密的硬盘</h4><p>输入 <strong>cryptsetup luksOpen /dev/sdb1 test</strong> ，并且输入密码后，硬盘 /dev/sdb1 会被映射到 /dev/mapper/test 下。</p>
<p><img src="https://s2.loli.net/2023/07/19/ilZHdaYOQ84rT1D.jpg" alt="打开硬盘"></p>
<h4 id="格式化映射的设备"><a href="#格式化映射的设备" class="headerlink" title="格式化映射的设备"></a>格式化映射的设备</h4><p>现在还需要再格式化一下映射的设备，执行 <strong>mkfs.ext4 /dev/mapper/test</strong>，这步操作只需在第一次打开设备时需要，以后再打开、挂载硬盘可以就无需这步操作了。</p>
<p><img src="https://s2.loli.net/2023/07/19/kDg42AHKQ7CqGOe.jpg" alt="格式化映射设备"></p>
<h4 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h4><p>这个时候想要挂载硬盘，直接把映射的目录挂载就行， <strong>mount /dev/mapper/test /home/HandsomeDong</strong> 。</p>
<p><img src="https://s2.loli.net/2023/07/19/vRxLehsAQToXDwN.jpg" alt="挂载硬盘"></p>
<h3 id="卸载硬盘"><a href="#卸载硬盘" class="headerlink" title="卸载硬盘"></a>卸载硬盘</h3><p>想要卸载、拔出硬盘，需要先卸载挂载点，再关闭映射的设备，切忌热插拔，容易损坏硬盘。<br>卸载挂载点 <strong>umount /home/HandsomeDong</strong><br>关闭映射设备 <strong>cryptsetup luksClose test</strong><br><img src="https://s2.loli.net/2023/07/19/LO8etlr17kXp6VP.jpg" alt="卸载硬盘"></p>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="数据无法读取"><a href="#数据无法读取" class="headerlink" title="数据无法读取"></a>数据无法读取</h4><p>硬盘意外断电再重新挂载时可能会造成数据无法读取，这时可以使用fsck修复指定分区。<br><strong>fsck /dev/mapper/HandsomeDong</strong></p>
<p><img src="https://s2.loli.net/2023/07/19/M4UCybjR5ahVZDQ.jpg" alt="修复分区"></p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>二维数组的查找</title>
    <url>/2019/06/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一个有序矩阵，可以从左下角或者右上角开始查找。例如从右上角开始查找，查找数字比当前数字大时，下移，反之则左移。直到边界都没找到的话，则该数组不含有该整数。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        int rowTotal = array.size(), columnTotal = array[0].size();</span><br><span class="line">        bool hasTarget = false;</span><br><span class="line">		</span><br><span class="line">        if ((rowTotal == 0) || (columnTotal == 0))&#123;</span><br><span class="line">            return false;  //空数组直接返回false</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0, j = columnTotal - 1; (i &lt;= rowTotal - 1) &amp;&amp;(j &gt;= 0);)&#123;</span><br><span class="line">            if (array[i][j] == target)&#123;</span><br><span class="line">                hasTarget = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if (array[i][j] &lt; target)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return hasTarget;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
        <category>剑指offer算法题</category>
      </categories>
  </entry>
  <entry>
    <title>删除链表中重复的结点</title>
    <url>/2019/06/21/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题做了比较久……感觉有一点点难写。</p>
<p>主要看下面这幅图理解</p>
<p><img src="https://i.loli.net/2019/06/21/5d0cdbe594eda16090.png" alt="思路图"></p>
<p>先建一个头结点，返回的时候返回这个头结点。<br>再建两个临时结点p、q，p用来作存储结点，q用来跳过重复结点。如图中第二个q的位置，先判断p的下一个结点位置是否与q一样，不一样的话先把q的下一个结点位置存到p的下一个结点，这样就先跳过了前面的重复结点。如果p的下一个结点是一样的，那就是图中第二个p的位置那里，这个时候证明了当前的q结点是不重复的，此时p直接存储q结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pHead == NULL || pHead-&gt;next == NULL) &#123;</span><br><span class="line">            return pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = -1;</span><br><span class="line">        if (pHead-&gt;val == first) &#123;</span><br><span class="line">            first = -2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *head = new ListNode(first);</span><br><span class="line">        head-&gt;next = pHead;</span><br><span class="line">        </span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        ListNode *q = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        while (q != NULL) &#123;</span><br><span class="line">            while ((q-&gt;next != NULL) &amp;&amp; (q-&gt;val == q-&gt;next-&gt;val)) &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (p-&gt;next != q) &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
        <category>剑指offer算法题</category>
      </categories>
  </entry>
  <entry>
    <title>求1+2+3+…...+n</title>
    <url>/2019/07/01/%E6%B1%821-2-3-%E2%80%A6-n/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>有一种很妙很简洁的解法，用 &amp;&amp; 短路，然后递归。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        n &amp;&amp; (n += Sum_Solution(n-1));</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
        <category>剑指offer算法题</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2019/06/16/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h2><p>有时候在京东看到一些电子产品非常想买，但奈何没钱啊！只能每隔几天就上京东看看这件商品有没有降价，有几次都错过了优惠活动！这让我悔恨不已啊！！！后来才发现京东有个“关注商品”的功能，商品一旦降价就会立马给我推送信息！我居然一直没发现！自从知道有这个功能后，我……</p>
<p><img src="https://i.loli.net/2019/06/17/5d067fadd1f5e93632.jpg" alt="穷啊"></p>
<p>其实设计模式里面也有一种模式类似于这种机制，那就是观察者模式。从此以后我再也没有错过商品的降价信息，</p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>观察者模式(Observer Pattern)建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为主题或者观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<p>观察者模式包含以下角色：</p>
<ol>
<li>主题</li>
<li>具体主题</li>
<li>观察者 </li>
<li>具体观察者</li>
</ol>
<h2 id="2-实例说明"><a href="#2-实例说明" class="headerlink" title="2.实例说明"></a>2.实例说明</h2><p>以点外卖的例子来说，我们通常在饿了么、美团这些APP上点外卖，我们在APP下单后，相应餐厅的APP此时会提醒接单，与此同时配送员的手机APP会立马提醒抢单。这个时候，每个订单都是具体主题，而餐厅及配送员就是具体观察者，下面用代码来实现。</p>
<h3 id="2-1-Observer接口"><a href="#2-1-Observer接口" class="headerlink" title="2.1 Observer接口"></a>2.1 Observer接口</h3><p>观察者都需要实现这个接口，当数据更新后，主题调用update()方法，把数据传送给观察者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    public void update(String food, String address, String phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Subject接口"><a href="#2-2-Subject接口" class="headerlink" title="2.2 Subject接口"></a>2.2 Subject接口</h3><p>主题最起码需要实现三个方法，registerObserver()方法用于观察者订阅主题，removeObserver()用于观察者取消订阅主题，notifyObserver()用于推送最新数据给观察者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    public void registerObserver(Observer observer);</span><br><span class="line">    public void removeObserver(Observer observer);</span><br><span class="line">    public void notifyObserver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-实现Observer接口"><a href="#2-3-实现Observer接口" class="headerlink" title="2.3 实现Observer接口"></a>2.3 实现Observer接口</h3><p>在构造的时候就订阅主题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//餐厅</span><br><span class="line">public class Restaurant implements Observer &#123;</span><br><span class="line">    private String food;</span><br><span class="line"></span><br><span class="line">    public Restaurant(Subject subject) &#123;</span><br><span class="line">        subject.registerObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(String food, String address, String phone) &#123;</span><br><span class="line">        this.food = food;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display()&#123;</span><br><span class="line">        System.out.println(&quot;餐厅，有订单了！用户点的菜是：&quot; + this.food + &quot;，是否接单？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void  unlink(Subject subject)&#123;</span><br><span class="line">        subject.removeObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//配送员</span><br><span class="line">public class DeliverGuy implements Observer &#123;</span><br><span class="line">    private String address;</span><br><span class="line">    private String phone;</span><br><span class="line"></span><br><span class="line">    public DeliverGuy(Subject subject) &#123;</span><br><span class="line">        subject.registerObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(String food, String address, String phone) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.phone = phone;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;外卖员，有订单了！地址是：&quot; + this.address + &quot;,手机号码是：&quot; + this.phone + &quot;，是否接单？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlink(Subject subject) &#123;</span><br><span class="line">        subject.removeObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-实现Subject接口"><a href="#2-4-实现Subject接口" class="headerlink" title="2.4 实现Subject接口"></a>2.4 实现Subject接口</h3><p>把所有订阅该主题的观察者对象放进一个ArrayList里，有数据更新的时候逐个调用它们的update()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Application implements Subject &#123;</span><br><span class="line">    private ArrayList observers;</span><br><span class="line">    private String food;</span><br><span class="line">    private String address;</span><br><span class="line">    private String phone;</span><br><span class="line"></span><br><span class="line">    public Application() &#123;</span><br><span class="line">        observers = new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer observer) &#123;</span><br><span class="line">        int i = observers.indexOf(observer);</span><br><span class="line">        if (i &gt;= 0) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObserver() &#123;</span><br><span class="line">        for (int i = 0; i &lt; observers.size(); i++) &#123;</span><br><span class="line">            Observer observer = (Observer) observers.get(i);</span><br><span class="line">            observer.update(food, address, phone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void comeNewOrder(String food, String address, String phone) &#123;</span><br><span class="line">        this.food = food;</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.phone = phone;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>测试代码和测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Application application = new Application();</span><br><span class="line">        Restaurant restaurant = new Restaurant(application);</span><br><span class="line">        DeliverGuy deliverGuy = new DeliverGuy(application);</span><br><span class="line"></span><br><span class="line">        application.comeNewOrder(&quot;番茄炒蛋饭&quot;, &quot;富华西路106号&quot;, &quot;12345678910&quot;);</span><br><span class="line"></span><br><span class="line">        deliverGuy.unlink(application); //该配送员送完上一单不想再送了，不再接受接单消息</span><br><span class="line">        application.comeNewOrder(&quot;土豆牛肉饭&quot;, &quot;富华东路178号&quot;, &quot;18910245613&quot;);</span><br><span class="line"></span><br><span class="line">        restaurant.unlink(application); //餐厅打烊了，不再接受订单消息</span><br><span class="line">        application.comeNewOrder(&quot;番茄炒蛋饭&quot;, &quot;富华西路123号&quot;, &quot;17654245645&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/06/17/5d067a6b9691d79258.png" alt="测试结果"></p>
<h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><p>1.观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。<br>2.观察者模式符合“开闭原则”的要求。</p>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><p>1.如果一个主题有很多直接和间接的观察者的话，所有的观察者都通知会花费很多时间。<br>2.观察者模式没有相应的机制让观察者知道所观察的主题是怎么发生变化的，而仅仅只是知道主题发生了变化。</p>
<h2 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5.适用场景"></a>5.适用场景</h2><p>观察者模式在软件开发中应用非常广泛，就比如我上面提到的京东降价消息，或者某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2019/06/19/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先从前到后遍历一次，计算有多少个空格，然后再从后到前逐个替换。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">            if(*(str+i)==&apos; &apos;)</span><br><span class="line">                count++;</span><br><span class="line">			cout &lt;&lt; *(str+i);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">            if (*(str+i) != &apos; &apos;)&#123;</span><br><span class="line">                *(str+i+count*2) = *(str+i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                count--;</span><br><span class="line">                *(str+i+(count)*2) = &apos;%&apos;;</span><br><span class="line">                *(str+i+(count)*2+1) = &apos;2&apos;;</span><br><span class="line">                *(str+i+(count)*2+2) = &apos;0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        char ch[] = str.toString().toCharArray();</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; ch.length; i++) &#123;</span><br><span class="line">            if (ch[i] == &apos; &apos;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char tmp[] = new char[ch.length + 2 * count];</span><br><span class="line"></span><br><span class="line">        for (int i = ch.length-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if (ch[i] != &apos; &apos;) &#123;</span><br><span class="line">                tmp[i + 2 * count] = ch[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp[i + 2 * count] = &apos;0&apos;;</span><br><span class="line">                tmp[i + 2 * count - 1] = &apos;2&apos;;</span><br><span class="line">                tmp[i + 2 * count - 2] = &apos;%&apos;;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
        <category>剑指offer算法题</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2019/06/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式之策略模式"><a href="#设计模式之策略模式" class="headerlink" title="设计模式之策略模式"></a>设计模式之策略模式</h1><p>以前听说过设计模式，但没有了解、学习过，最近买了本《Head First设计模式》来看，感觉设计模式真是太妙了！！！想来实在惭愧，现在才开始学习设计模式！</p>
<p><img src="https://i.loli.net/2019/06/17/5d067ce888ffd96560.png" alt="我技术好菜啊"></p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>策略模式(Strategy Pattern)是指对一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<h2 id="2-实例说明"><a href="#2-实例说明" class="headerlink" title="2.实例说明"></a>2.实例说明</h2><p>比如现在就想实现很简单的功能——学生在学习，老师在授课。学习和授课都是角色当前的一个动作、状态，我们可以把这一类随时可变的动作从角色里抽离出来并封装起来。</p>
<h3 id="2-1-动作接口"><a href="#2-1-动作接口" class="headerlink" title="2.1 动作接口"></a>2.1 动作接口</h3><p>首先定义一个动作接口，所有的具体动作都要实现这个接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Action &#123;</span><br><span class="line">    public void action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-具体动作实现接口"><a href="#2-2-具体动作实现接口" class="headerlink" title="2.2 具体动作实现接口"></a>2.2 具体动作实现接口</h3><p>接下来就是具体动作了，授课、学习、睡觉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 授课动作</span><br><span class="line">public class TeachAction implements Action &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void action() &#123;</span><br><span class="line">        System.out.println(&quot;正在授课！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 学习动作</span><br><span class="line">public class LearnAction implements Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void action() &#123;</span><br><span class="line">        System.out.println(&quot;正在学习！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 睡觉动作</span><br><span class="line">public class SleepAction implements Action &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void action() &#123;</span><br><span class="line">        System.out.println(&quot;正在睡大觉！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Person抽象类"><a href="#2-3-Person抽象类" class="headerlink" title="2.3 Person抽象类"></a>2.3 Person抽象类</h3><p>定义抽象类 Person，在该类里加入两个实例变量，一个是字符串变量name，一个是Action接口类型action（而不是具体类实现类型）。方法doing()里调用action的action()方法。Person抽象类不用关心action的具体对象到底是什么，它只需关心该对象能有action()就行了。并且建一个setAction()来通过动态改变action的具体实现类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Person &#123;</span><br><span class="line">    Action action;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doing() &#123;</span><br><span class="line">        System.out.print(name);</span><br><span class="line">        action.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAction(Action action)&#123;</span><br><span class="line">        this.action = action;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-具体角色类继承Person类"><a href="#2-4-具体角色类继承Person类" class="headerlink" title="2.4 具体角色类继承Person类"></a>2.4 具体角色类继承Person类</h3><p>Teacher类在构造时将action实例变量初始化为TeachAction的新实例，而Student类则将action实例变量初始化为LearnAction的新实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Teacher类</span><br><span class="line">public class Teacher extends Person&#123;</span><br><span class="line">    public Teacher(String name) &#123;</span><br><span class="line">        this.action = new TeachAction();</span><br><span class="line">        this.name = name + &quot;老师&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Student类</span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">    public Student(String name)&#123;</span><br><span class="line">        this.action = new LearnAction();</span><br><span class="line">        this.name = name + &quot;同学&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>测试代码和测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    Person handsomeDong = new Teacher(&quot;帅比东&quot;);</span><br><span class="line">    Person xiaoQiang = new Student(&quot;小强&quot;);</span><br><span class="line"></span><br><span class="line">    handsomeDong.doing();</span><br><span class="line">    xiaoQiang.doing();</span><br><span class="line"></span><br><span class="line">    xiaoQiang.setAction(new SleepAction());</span><br><span class="line">    xiaoQiang.doing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/06/16/5d0517243e28624089.png" alt="测试结果"></p>
<h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><p>1.算法可以自由切换，改策略很方便<br>2.增加一个策略，就多增加一个类实现接口就好了。</p>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><p>每一个策略都是一个类，复用的可能性很小、类数量增多</p>
<h2 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5.适用场景"></a>5.适用场景</h2><p>1.许多相关类仅仅是行为不同。<br>2.需要使用一个算法的不同实现。<br>3.算法使用了客户不应该知道的数据。策略模式可以避免暴露复杂的、与算法相关的数据结构。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>记一次简单的服务启动GC优化</title>
    <url>/2021/01/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8GC%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天上线一个项目的时候在日志里发现项目启动的时候频繁GC，花了点时间分析了一下并且调整了一下JVM参数。</p>
<h1 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h1><p>项目启动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">java -server -Xmx1024m -XX:MaxDirectMemorySize=<span class="number">512</span>M -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.txt -jar xxxxxxxx.jar</span><br></pre></td></tr></table></figure>
<p>gc.txt<br><img src="https://s2.loli.net/2023/07/19/aQRo95fxWqPhcNH.png" alt="GC记录"><br>好家伙，一启动就来9次 Young GC ，2次 Full GC。</p>
<p>现在先用jinfo看看配置参数<br><img src="https://s2.loli.net/2023/07/19/zNqOUMf6sYXjipV.png" alt="查看JVM参数"><br>注意几个重要参数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">62914560</span>		<span class="comment">//堆初始值</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">1073741824</span>	<span class="comment">//堆最大值</span></span><br><span class="line">-MaxDirectMemorySize=<span class="number">536870912</span>	<span class="comment">//虚拟机外最大内存</span></span><br></pre></td></tr></table></figure></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>先来分析这两次Full GC以及它们前面的Young GC</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2.536</span>: [GC (Metadata GC Threshold) [PSYoungGen: <span class="number">19883</span>K-&gt;<span class="number">3584</span>K(<span class="number">128512</span>K)] <span class="number">27143</span>K-&gt;<span class="number">12014</span>K(<span class="number">169472</span>K), <span class="number">0.0158155</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"><span class="number">2.552</span>: [Full GC (Metadata GC Threshold) [PSYoungGen: <span class="number">3584</span>K-&gt;<span class="number">0</span>K(<span class="number">128512</span>K)] [ParOldGen: <span class="number">8430</span>K-&gt;<span class="number">8782</span>K(<span class="number">32256</span>K)] <span class="number">12014</span>K-&gt;<span class="number">8782</span>K(<span class="number">160768</span>K), [Metaspace: <span class="number">20409</span>K-&gt;<span class="number">20409</span>K(<span class="number">1069056</span>K)], <span class="number">0.0844666</span> secs] [Times: user=<span class="number">0.16</span> sys=<span class="number">0.00</span>, real=<span class="number">0.09</span> secs]</span><br><span class="line"><span class="number">4.965</span>: [GC (Metadata GC Threshold) [PSYoungGen: <span class="number">109848</span>K-&gt;<span class="number">8697</span>K(<span class="number">247296</span>K)] <span class="number">119422</span>K-&gt;<span class="number">19608</span>K(<span class="number">279552</span>K), <span class="number">0.0278398</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.01</span>, real=<span class="number">0.03</span> secs]</span><br><span class="line"><span class="number">4.993</span>: [Full GC (Metadata GC Threshold) [PSYoungGen: <span class="number">8697</span>K-&gt;<span class="number">0</span>K(<span class="number">247296</span>K)] [ParOldGen: <span class="number">10910</span>K-&gt;<span class="number">14513</span>K(<span class="number">47104</span>K)] <span class="number">19608</span>K-&gt;<span class="number">14513</span>K(<span class="number">294400</span>K), [Metaspace: <span class="number">33512</span>K-&gt;<span class="number">33512</span>K(<span class="number">1081344</span>K)], <span class="number">0.1136122</span> secs] [Times: user=<span class="number">0.20</span> sys=<span class="number">0.00</span>, real=<span class="number">0.11</span> secs]</span><br></pre></td></tr></table></figure>
<p>可以看到两次Full GC都是由于Metadata GC Threshold造成的。我这里用的是JDK8，参数里没有明确指定metaspace的初始值和上限，这个时候初始值应该是默认的 21M 。问题不大，那我就把它的初始值和上限调大一点吧，调到64M。</p>
<p>措施：<br><strong>追加元空间初始值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">java -server -XX:MetaspaceSize=<span class="number">64</span>m -XX:MaxMetaspaceSize=<span class="number">64</span>m -Xmx1024m -XX:MaxDirectMemorySize=<span class="number">512</span>M  -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.txt -jar xxxxxxxx.jar</span><br></pre></td></tr></table></figure>
<p>这个时候再查看gc.txt<br><img src="https://s2.loli.net/2023/07/19/2KRfYgMJQ9O7Ix3.png" alt="gc.txt"><br>可以看到已经没有Full GC了，不过还是有8次Young GC。</p>
<h2 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h2><p>其实从我的启动参数里面就可以看到，<strong>堆的容量我只指定了最大值(-Xmx1024m)</strong>，并没有指定初始值。所以可以在配置参数里面看到 -XX:InitialHeapSize=62082048，即<strong>堆的初始容量只有60m左右。</strong></p>
<p>而JVM默认的新生代和老年代空间占比为 <strong>1 : 3</strong>，所以新生代在一开始的时候只有15m的内存空间，因此JVM一开始在15m的时候就发生了Young GC。</p>
<p>所以现在要追加新生代和堆的初始值，新生代、老年代的空间占比我就不调了，使用默认的 1 : 3 即可，而堆的初始值调成1024m，这样新生代的初始值就是256m了。</p>
<p>措施：<br><strong>追加堆的初始值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">java -server -Xms1024m -XX:MetaspaceSize=<span class="number">64</span>m -XX:MaxMetaspaceSize=<span class="number">64</span>m -Xmx1024m -XX:MaxDirectMemorySize=<span class="number">512</span>M  -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.txt -jar xxxxxxxx.jar</span><br></pre></td></tr></table></figure>
<p>现在再来看看gc.txt<br><img src="https://s2.loli.net/2023/07/19/fCu3ZRwygo4sKPp.png" alt="gc.txt"><br>可以看到只有两次Young GC了，这两次Young GC是在新生代对象准备超过256m的时候发生的……</p>
<p><strong>好家伙，既然如此，那我也不讲武德了，我现在就把堆初始值和最大值都调成100G。</strong></p>
<p><img src="https://s2.loli.net/2023/07/19/w5uLGkR37OKZDIl.png" alt="过分"></p>
<p>好吧，公司穷，只能买得起4G的服务器。</p>
<p><img src="https://s2.loli.net/2023/07/19/kHAfcxd9qeQhron.png" alt="哭了"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这只是一次很简单的JVM启动参数优化，平时启动应用的时候还是得多注意注意堆的初始值和最大值配置，元空间这部分也不能忽略了。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM优化</tag>
      </tags>
  </entry>
  <entry>
    <title>除了 Websocket ，服务端还有什么办法能向浏览器主动推送信息？</title>
    <url>/2021/11/13/%E9%99%A4%E4%BA%86-Websocket-%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E8%83%BD%E5%90%91%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E4%BF%A1%E6%81%AF%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>打工的时候，偶尔在闲暇时刻偷偷打开一下股票网站，看看今天有没有赚钱，说不定哪天一夜暴富，这是我现在唯一的盼头……</p>
<p><img src="https://s2.loli.net/2023/07/19/euz1TniqLF2o7SI.jpg" alt="流泪打工人"></p>
<p>今天我一如往常打开熟悉的“XX财富网”，输入熟悉的股票代码，点开我前几天刚买入的“XXX”……</p>
<p><img src="https://s2.loli.net/2023/07/19/7CPtpYo3VjMIRhy.gif" alt="绿"></p>
<p>看着冒着绿光并且一闪一闪的屏幕，我陷入了沉思……</p>
<p><img src="https://s2.loli.net/2023/07/19/K6dpJc7P23Z8iSD.jpg" alt="沉思"></p>
<p><strong>我恍惚了一下，心想这实时刷新的数据，是后端通过websocket推过来的吗？</strong></p>
<p>于是我F12看了一下，<strong>没有 websocket 连接啊！</strong></p>
<p><img src="https://s2.loli.net/2023/07/19/7NDhloYLMPnKciZ.png" alt="没有websocket"></p>
<p><strong>难道除了 Websocket 还有别的办法能够让后端向前端主动推送消息？</strong></p>
<p>我马上想到了 http2.0 的 server push ，但是想了想又觉得不太可能，因为 http2.0 的push并不是这个意思。</p>
<p><strong>http2.0 的 server push 指的是：服务器还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了 index.html，但是服务器发现 index.html 内容里面需要用到 style.css、example.png，于是服务器在浏览器请求 index.html时顺便把 style.css、example.png 也一起发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</strong></p>
<p>所以很明显，http2.0 的 server push 只是复用其中一条http连接顺便把后续需要发送的一些静态资源提前发给了浏览器，并不<strong>适用于这种推送动态数据的场景</strong>（比如股票涨跌数据实时刷新、直播弹幕推送等）。</p>
<p>那服务器究竟是怎么实时推送了股票相关的数据呢？</p>
<h1 id="端倪"><a href="#端倪" class="headerlink" title="端倪"></a>端倪</h1><p>于是我点开了 Fetch/XHR 看看到底是何方神圣，在不断推送数据。于是我发现了这几个请求的内容好像不断地在刷新……</p>
<p>从下图可以看到一秒钟推送好几条数据过来（现在是十一点半，我打开了美股）</p>
<p><img src="https://s2.loli.net/2023/07/19/9ROFre7IysTmwzv.png" alt="端倪"></p>
<p>查看这几个http请求，很容易就发现请求头和响应头的 Content-Type 和 Accept 跟其它普通的http请求不太一样。</p>
<p><img src="https://s2.loli.net/2023/07/19/U1qVtv7mO6McDiH.png" alt="头"></p>
<p>很明显，这个服务端推送，跟这个 text/event-stream 关系很大。</p>
<p><img src="https://s2.loli.net/2023/07/19/DE4y1Q5nNtKHsOI.gif" alt="真相只有一个"></p>
<p>于是我去查了一下相关资料，果不其然……<strong>服务器向浏览器推送信息，除了 WebSocket，还有一种方法：Server-Sent Events。</strong></p>
<h1 id="Server-Sent-Events-是什么？"><a href="#Server-Sent-Events-是什么？" class="headerlink" title="Server-Sent Events 是什么？"></a>Server-Sent Events 是什么？</h1><p>Server-Sent Events，服务器发送事件，简称SSE，是一种 HTML 5 事件通知，它允许网页获得来自服务器的更新。</p>
<p>严格来说，HTTP 协议是没有办法做到服务器主动推送信息的，但是有一种变通的方法可以做到，那就是服务器向客户端声明接下来要发送的是流信息（streaming）。</p>
<p>也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p>
<p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP 协议，目前除了 IE/Edge，其他浏览器都支持。</p>
<h1 id="Server-Sent-Events-与-Websocket-对比"><a href="#Server-Sent-Events-与-Websocket-对比" class="headerlink" title="Server-Sent Events 与 Websocket 对比"></a>Server-Sent Events 与 Websocket 对比</h1><p>既然能让服务器主动向浏览器推送信息，那我们肯定会想到让websocket来跟它做做对比。</p>
<p>总的来说，Websocket 应该是更强大、更灵活、应用更广泛的，因为它是全双工通信，可以双向通信；但是SSE是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。<br><img src="https://s2.loli.net/2023/07/19/9QgO1zIvSjAcw7F.png" alt="SSE"><br>但是，SSE也有自己的优点。</p>
<ul>
<li>SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</li>
<li>SSE 比较轻量级，使用较简单；WebSocket 协议相对来说比较复杂。</li>
<li>SSE 默认支持断线重连，而WebSocket 需要自己实现。</li>
<li>SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</li>
<li>SSE 支持自定义发送的消息类型。</li>
</ul>
<p>所以 SSE 和 Websocket 适合不同的使用场景。</p>
<p>迟点有空的时候写个demo试试。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>除了 Websocket ，服务端还能通过 SSE 向浏览器主动推送消息，其本质上就是一个基于 HTTP 的流。</li>
<li>今天的工不白打，股市虽绿，但我因此收获了一个冷门的知识点<del>安慰自己</del> 。</li>
</ul>
<p><img src="https://s2.loli.net/2023/07/19/NAxtRGfvVPlozEe.jpg" alt="我真的没哭"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>Server-Sent Events</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2019/06/21/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式之装饰者模式"><a href="#设计模式之装饰者模式" class="headerlink" title="设计模式之装饰者模式"></a>设计模式之装饰者模式</h2><p>最近在买奶茶的时候突发奇想，假如我要设计一个奶茶订单系统，这个奶茶价格计算要怎样设计才算方便呢？毕竟奶茶种类那么多，而且能加的配料也很多，并且奶茶店可能随时还会增加奶茶的种类及可选的配料，想要满足这些经常改变或增加的需求，怎么设计代码才是易维护、易扩展的呢？在了解了装饰者模式之后，我终于知道该怎么做了！</p>
<p><img src="https://i.loli.net/2019/06/21/5d0cf8c3a00af59704.png" alt="奶茶奶茶奶茶"></p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>装饰者模式(Decorator Pattern)动态地将责任附加在对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p>装饰者模式包含以下角色：</p>
<ol>
<li>抽象构件</li>
<li>具体构件</li>
<li>抽象装饰类</li>
<li>具体装饰类</li>
</ol>
<h2 id="2-实例说明"><a href="#2-实例说明" class="headerlink" title="2.实例说明"></a>2.实例说明</h2><p> 按照大白话来讲，抽象构件就是奶茶，具体构件是珍珠奶茶、波霸奶茶、红豆奶茶这些具体的奶茶。而抽象装饰类和具体装饰类是装饰者模式的设计核心了，利用它们我们可以动态地给奶茶加上配料。</p>
<h3 id="2-1-抽象奶茶类"><a href="#2-1-抽象奶茶类" class="headerlink" title="2.1 抽象奶茶类"></a>2.1 抽象奶茶类</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class MilkTea &#123;</span><br><span class="line">    public abstract String getDescription();</span><br><span class="line">    public abstract int cost();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-具体奶茶类"><a href="#2-2-具体奶茶类" class="headerlink" title="2.2 具体奶茶类"></a>2.2 具体奶茶类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 波霸奶茶，一杯15块钱</span><br><span class="line">public class BoBaMilkTea extends MilkTea &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;波霸奶茶&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return 15;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 红豆奶茶，一杯12块钱</span><br><span class="line">public class HongDouMilkTea extends MilkTea &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;红豆奶茶&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return 12;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-抽象配料类"><a href="#2-3-抽象配料类" class="headerlink" title="2.3 抽象配料类"></a>2.3 抽象配料类</h3><p>由于我们是让配料来扩展奶茶，因此需要继承抽象奶茶类并且实现里面的抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Decorator extends MilkTea&#123;</span><br><span class="line">    private MilkTea milkTea;</span><br><span class="line"></span><br><span class="line">    public Decorator(MilkTea milkTea)&#123;</span><br><span class="line">        this.milkTea = milkTea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return milkTea.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return milkTea.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-具体配料类"><a href="#2-4-具体配料类" class="headerlink" title="2.4 具体配料类"></a>2.4 具体配料类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 加奇异果要3块钱！</span><br><span class="line">public class QiYiGuoDecorator extends Decorator &#123;</span><br><span class="line">    public QiYiGuoDecorator(MilkTea milkTea)&#123;</span><br><span class="line">        super(milkTea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return super.getDescription() + &quot; 加奇异果&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return super.cost() + 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 加椰果才要2块钱！</span><br><span class="line">public class YeGuoDecorator extends Decorator &#123;</span><br><span class="line">    public YeGuoDecorator(MilkTea milkTea)&#123;</span><br><span class="line">        super(milkTea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return super.getDescription() + &quot; 加椰果&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int cost() &#123;</span><br><span class="line">        return super.cost() + 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>测试代码和测试结果如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        //先来一杯红豆奶茶，加椰果，加奇异果！</span><br><span class="line">        MilkTea hongDouMilkTea = new HongDouMilkTea();</span><br><span class="line">        hongDouMilkTea = new YeGuoDecorator(hongDouMilkTea);</span><br><span class="line">        hongDouMilkTea = new QiYiGuoDecorator(hongDouMilkTea);</span><br><span class="line">        System.out.println(hongDouMilkTea.getDescription() + &quot;，价格：&quot; + hongDouMilkTea.cost() + &quot;元&quot;);</span><br><span class="line"></span><br><span class="line">        //再来一杯波霸奶茶，再加双倍椰果，别问我为什么！我爱椰果！</span><br><span class="line">        MilkTea boBaMilkTea = new BoBaMilkTea();</span><br><span class="line">        boBaMilkTea = new YeGuoDecorator(boBaMilkTea);</span><br><span class="line">        boBaMilkTea = new YeGuoDecorator(boBaMilkTea);</span><br><span class="line">        System.out.println(boBaMilkTea.getDescription() + &quot;，价格：&quot; + boBaMilkTea.cost() + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/06/22/5d0d03ced660424319.png" alt="测试结果"></p>
<h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><p>1.装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。<br>2.通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。<br>3.具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</p>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><p>1.使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度。<br>2.这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</p>
<h2 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5.适用场景"></a>5.适用场景</h2><p>1.当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.<br>2.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>跳台阶</title>
    <url>/2019/06/20/%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>f(n) = f(n-1) + f(n-2)</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if (number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (number == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (number ==2) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return jumpFloor(number - 1) + jumpFloor(number - 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if (number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if ((number == 1) || (number == 2))&#123;</span><br><span class="line">            return number;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int first = 2, second = 1, sum = 0;</span><br><span class="line">        </span><br><span class="line">        for (int i = 3; i &lt;= number; i++) &#123;</span><br><span class="line">            sum = first + second;</span><br><span class="line">            second = first;</span><br><span class="line">            first = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
        <category>剑指offer算法题</category>
      </categories>
  </entry>
</search>
